<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>十、事件种类 | 前端知识</title>
    <meta name="description" content="一个总结前端知识的文档网站">
    <link rel="icon" href="/logo.png">
  <script defer="defer" src="/static/jquery.slim.min.js"></script>
  <script defer="defer" src="/static/jquery.fancybox.min.js"></script>
  <link defer="defer" rel="stylesheet" type="text/css" href="/static/jquery.fancybox.min.css">
    
    <link rel="preload" href="/assets/css/0.styles.f853b4b7.css" as="style"><link rel="preload" href="/assets/js/app.775950a1.js" as="script"><link rel="preload" href="/assets/js/81.3891d4d6.js" as="script"><link rel="prefetch" href="/assets/js/10.6c44e435.js"><link rel="prefetch" href="/assets/js/100.98af6c3f.js"><link rel="prefetch" href="/assets/js/101.48d54f64.js"><link rel="prefetch" href="/assets/js/102.129a7b52.js"><link rel="prefetch" href="/assets/js/103.10eca49c.js"><link rel="prefetch" href="/assets/js/104.50d7d876.js"><link rel="prefetch" href="/assets/js/105.096bd294.js"><link rel="prefetch" href="/assets/js/106.34c2dfeb.js"><link rel="prefetch" href="/assets/js/107.ee695784.js"><link rel="prefetch" href="/assets/js/108.1bfbd82d.js"><link rel="prefetch" href="/assets/js/109.e3a3585f.js"><link rel="prefetch" href="/assets/js/11.4b0dbe7e.js"><link rel="prefetch" href="/assets/js/110.d7461d00.js"><link rel="prefetch" href="/assets/js/111.633fe979.js"><link rel="prefetch" href="/assets/js/112.5f7790db.js"><link rel="prefetch" href="/assets/js/113.2313fbd8.js"><link rel="prefetch" href="/assets/js/114.e9411169.js"><link rel="prefetch" href="/assets/js/115.521e230d.js"><link rel="prefetch" href="/assets/js/116.b09bb4f8.js"><link rel="prefetch" href="/assets/js/117.ed527f17.js"><link rel="prefetch" href="/assets/js/118.bd02124f.js"><link rel="prefetch" href="/assets/js/119.5f466511.js"><link rel="prefetch" href="/assets/js/12.642b7c08.js"><link rel="prefetch" href="/assets/js/120.54ea8711.js"><link rel="prefetch" href="/assets/js/121.491683c5.js"><link rel="prefetch" href="/assets/js/122.0f3a778f.js"><link rel="prefetch" href="/assets/js/123.f646571d.js"><link rel="prefetch" href="/assets/js/124.5729a85d.js"><link rel="prefetch" href="/assets/js/125.5fbad3c9.js"><link rel="prefetch" href="/assets/js/126.aa4ccf66.js"><link rel="prefetch" href="/assets/js/127.6784ebf7.js"><link rel="prefetch" href="/assets/js/128.6ea33084.js"><link rel="prefetch" href="/assets/js/129.5ba75c6d.js"><link rel="prefetch" href="/assets/js/13.4c5741c4.js"><link rel="prefetch" href="/assets/js/130.40139e9d.js"><link rel="prefetch" href="/assets/js/131.bb93d98d.js"><link rel="prefetch" href="/assets/js/132.329af62a.js"><link rel="prefetch" href="/assets/js/133.fc17842a.js"><link rel="prefetch" href="/assets/js/134.3255aff9.js"><link rel="prefetch" href="/assets/js/135.d7183705.js"><link rel="prefetch" href="/assets/js/136.85def739.js"><link rel="prefetch" href="/assets/js/137.8f3e6657.js"><link rel="prefetch" href="/assets/js/138.6bd6f6de.js"><link rel="prefetch" href="/assets/js/139.e1f0e12f.js"><link rel="prefetch" href="/assets/js/14.c40076df.js"><link rel="prefetch" href="/assets/js/140.83de1531.js"><link rel="prefetch" href="/assets/js/141.5ed47066.js"><link rel="prefetch" href="/assets/js/142.bce834c0.js"><link rel="prefetch" href="/assets/js/143.b15fed8b.js"><link rel="prefetch" href="/assets/js/144.2bdb3b43.js"><link rel="prefetch" href="/assets/js/145.d80e33fe.js"><link rel="prefetch" href="/assets/js/146.c11c2a25.js"><link rel="prefetch" href="/assets/js/147.b38962fa.js"><link rel="prefetch" href="/assets/js/148.d69f3f9c.js"><link rel="prefetch" href="/assets/js/149.14e641d8.js"><link rel="prefetch" href="/assets/js/15.53984755.js"><link rel="prefetch" href="/assets/js/150.b89ce1b7.js"><link rel="prefetch" href="/assets/js/151.e60afdef.js"><link rel="prefetch" href="/assets/js/152.8b5c1d78.js"><link rel="prefetch" href="/assets/js/153.ae8d9e61.js"><link rel="prefetch" href="/assets/js/154.df75c4e9.js"><link rel="prefetch" href="/assets/js/155.4593e073.js"><link rel="prefetch" href="/assets/js/156.a897070f.js"><link rel="prefetch" href="/assets/js/16.1269c0ab.js"><link rel="prefetch" href="/assets/js/17.f8a094b8.js"><link rel="prefetch" href="/assets/js/18.e44a028b.js"><link rel="prefetch" href="/assets/js/19.232b0c35.js"><link rel="prefetch" href="/assets/js/20.dd08f9d5.js"><link rel="prefetch" href="/assets/js/21.02356176.js"><link rel="prefetch" href="/assets/js/22.b9f0d214.js"><link rel="prefetch" href="/assets/js/23.af7f998b.js"><link rel="prefetch" href="/assets/js/24.55f7187b.js"><link rel="prefetch" href="/assets/js/25.676a9ada.js"><link rel="prefetch" href="/assets/js/26.6acb8ada.js"><link rel="prefetch" href="/assets/js/27.05214d03.js"><link rel="prefetch" href="/assets/js/28.5e603dc5.js"><link rel="prefetch" href="/assets/js/29.e093a5f3.js"><link rel="prefetch" href="/assets/js/3.a8f0d3e2.js"><link rel="prefetch" href="/assets/js/30.1abcd9a3.js"><link rel="prefetch" href="/assets/js/31.c2487b5a.js"><link rel="prefetch" href="/assets/js/32.ea784c06.js"><link rel="prefetch" href="/assets/js/33.562cbd3d.js"><link rel="prefetch" href="/assets/js/34.32f2c085.js"><link rel="prefetch" href="/assets/js/35.768bee1a.js"><link rel="prefetch" href="/assets/js/36.38385f0d.js"><link rel="prefetch" href="/assets/js/37.3333f4f3.js"><link rel="prefetch" href="/assets/js/38.b4d8add3.js"><link rel="prefetch" href="/assets/js/39.975009ed.js"><link rel="prefetch" href="/assets/js/4.18c4588b.js"><link rel="prefetch" href="/assets/js/40.4a3a790b.js"><link rel="prefetch" href="/assets/js/41.6b207d98.js"><link rel="prefetch" href="/assets/js/42.39a62773.js"><link rel="prefetch" href="/assets/js/43.0ffc2720.js"><link rel="prefetch" href="/assets/js/44.f17f25ab.js"><link rel="prefetch" href="/assets/js/45.53cfb08c.js"><link rel="prefetch" href="/assets/js/46.9deefe9e.js"><link rel="prefetch" href="/assets/js/47.ce8a6111.js"><link rel="prefetch" href="/assets/js/48.d32c90b5.js"><link rel="prefetch" href="/assets/js/49.e7ab3a9b.js"><link rel="prefetch" href="/assets/js/5.875fc844.js"><link rel="prefetch" href="/assets/js/50.29c4023a.js"><link rel="prefetch" href="/assets/js/51.f2837511.js"><link rel="prefetch" href="/assets/js/52.cb96cb7f.js"><link rel="prefetch" href="/assets/js/53.6dca9f5d.js"><link rel="prefetch" href="/assets/js/54.531caf7b.js"><link rel="prefetch" href="/assets/js/55.e8bbd49d.js"><link rel="prefetch" href="/assets/js/56.85e1ee0f.js"><link rel="prefetch" href="/assets/js/57.bd4cb714.js"><link rel="prefetch" href="/assets/js/58.66b1a8c4.js"><link rel="prefetch" href="/assets/js/59.abbd3154.js"><link rel="prefetch" href="/assets/js/6.bc72a1c2.js"><link rel="prefetch" href="/assets/js/60.3f803f83.js"><link rel="prefetch" href="/assets/js/61.6cddbd0d.js"><link rel="prefetch" href="/assets/js/62.e8cd0d46.js"><link rel="prefetch" href="/assets/js/63.6c9915a5.js"><link rel="prefetch" href="/assets/js/64.6b2be6f1.js"><link rel="prefetch" href="/assets/js/65.7361da19.js"><link rel="prefetch" href="/assets/js/66.02cdac53.js"><link rel="prefetch" href="/assets/js/67.0a394ff3.js"><link rel="prefetch" href="/assets/js/68.a2d4f0ba.js"><link rel="prefetch" href="/assets/js/69.da1bc91c.js"><link rel="prefetch" href="/assets/js/7.f8e21188.js"><link rel="prefetch" href="/assets/js/70.808b6c60.js"><link rel="prefetch" href="/assets/js/71.5fb1876d.js"><link rel="prefetch" href="/assets/js/72.b3c7a6da.js"><link rel="prefetch" href="/assets/js/73.3973398c.js"><link rel="prefetch" href="/assets/js/74.150e73da.js"><link rel="prefetch" href="/assets/js/75.6d807f6f.js"><link rel="prefetch" href="/assets/js/76.75efe257.js"><link rel="prefetch" href="/assets/js/77.a27205ed.js"><link rel="prefetch" href="/assets/js/78.a43eafbe.js"><link rel="prefetch" href="/assets/js/79.d5224e18.js"><link rel="prefetch" href="/assets/js/8.8eeaf86d.js"><link rel="prefetch" href="/assets/js/80.c0f856c8.js"><link rel="prefetch" href="/assets/js/82.de319974.js"><link rel="prefetch" href="/assets/js/83.d61c016c.js"><link rel="prefetch" href="/assets/js/84.efe08c8d.js"><link rel="prefetch" href="/assets/js/85.b611c88b.js"><link rel="prefetch" href="/assets/js/86.9a45684c.js"><link rel="prefetch" href="/assets/js/87.36076ea1.js"><link rel="prefetch" href="/assets/js/88.78017773.js"><link rel="prefetch" href="/assets/js/89.f845f250.js"><link rel="prefetch" href="/assets/js/9.812a22af.js"><link rel="prefetch" href="/assets/js/90.9c8a1d96.js"><link rel="prefetch" href="/assets/js/91.bd1f20bb.js"><link rel="prefetch" href="/assets/js/92.d85b144d.js"><link rel="prefetch" href="/assets/js/93.9db78afd.js"><link rel="prefetch" href="/assets/js/94.81bc2dfb.js"><link rel="prefetch" href="/assets/js/95.4f47dd92.js"><link rel="prefetch" href="/assets/js/96.46f295d6.js"><link rel="prefetch" href="/assets/js/97.e056f61f.js"><link rel="prefetch" href="/assets/js/98.10c98825.js"><link rel="prefetch" href="/assets/js/99.185020de.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.a4f1059c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f853b4b7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="前端知识" class="logo"> <span class="site-name can-hide">前端知识</span></a> <div class="links" style="max-width:nullpx;"><form id="search-form" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/catalog.html" class="nav-link">目录</a></div><div class="nav-item"><a href="/doc/es6/" class="nav-link">ES6</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/doc/js/" class="nav-link">js</a></li><li class="dropdown-item"><!----> <a href="/doc/js/standardLibrary/" class="nav-link">js标准库</a></li><li class="dropdown-item"><!----> <a href="/doc/dom/" class="nav-link router-link-active">dom操作文档</a></li><li class="dropdown-item"><!----> <a href="/doc/browserNetwork/" class="nav-link">浏览器、网络</a></li><li class="dropdown-item"><!----> <a href="/doc/designPattern/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/doc/css/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/doc/html/" class="nav-link">html</a></div><div class="nav-item"><a href="/doc/react/" class="nav-link">react</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>JS打包工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/doc/tool/webpack/" class="nav-link">webpack</a></li></ul></li></ul></div></div> <a href="https://github.com/yulilong/front-end-doc" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/catalog.html" class="nav-link">目录</a></div><div class="nav-item"><a href="/doc/es6/" class="nav-link">ES6</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/doc/js/" class="nav-link">js</a></li><li class="dropdown-item"><!----> <a href="/doc/js/standardLibrary/" class="nav-link">js标准库</a></li><li class="dropdown-item"><!----> <a href="/doc/dom/" class="nav-link router-link-active">dom操作文档</a></li><li class="dropdown-item"><!----> <a href="/doc/browserNetwork/" class="nav-link">浏览器、网络</a></li><li class="dropdown-item"><!----> <a href="/doc/designPattern/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/doc/css/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/doc/html/" class="nav-link">html</a></div><div class="nav-item"><a href="/doc/react/" class="nav-link">react</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>JS打包工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/doc/tool/webpack/" class="nav-link">webpack</a></li></ul></li></ul></div></div> <a href="https://github.com/yulilong/front-end-doc" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/doc/dom/" class="one-level sidebar-link">零、DOM</a></li><li><a href="/doc/dom/001-节点的类型.html" class="one-level sidebar-link">一、节点的类型</a></li><li><a href="/doc/dom/002-节点的关系.html" class="one-level sidebar-link">二、节点的关系</a></li><li><a href="/doc/dom/003-节点的操作.html" class="one-level sidebar-link">三、节点的操作</a></li><li><a href="/doc/dom/004-动态集合NodeLIst-HTMLCollection.html" class="one-level sidebar-link">四、动态集合NodeLIst-HTMLCollection等</a></li><li><a href="/doc/dom/005-Element.html" class="one-level sidebar-link">五、Element</a></li><li><a href="/doc/dom/006-Node.html" class="one-level sidebar-link">六、Node</a></li><li><a href="/doc/dom/007-Element对象.html" class="one-level sidebar-link">七、Element对象</a></li><li><a href="/doc/dom/008-document对象.html" class="one-level sidebar-link">八、document对象</a></li><li><a href="/doc/dom/009-事件模型.html" class="one-level sidebar-link">九、事件模型</a></li><li><a href="/doc/dom/010-事件种类.html" class="one-level one-level-active active sidebar-link">十、事件种类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_1-鼠标事件" class="sidebar-link">1. 鼠标事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_2-mouseevent-接口概述" class="sidebar-link">2. MouseEvent 接口概述</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-mouseevent-接口的实例属性" class="sidebar-link">3. MouseEvent 接口的实例属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-1-mouseevent-altkey，mouseevent-ctrlkey，mouseevent-metakey，mouseevent-shiftkey" class="sidebar-link">3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-2-mouseevent-button，mouseevent-buttons" class="sidebar-link">3.2 MouseEvent.button，MouseEvent.buttons</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-3-mouseevent-clientx，mouseevent-clienty" class="sidebar-link">3.3 MouseEvent.clientX，MouseEvent.clientY</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-4-mouseevent-movementx，mouseevent-movementy" class="sidebar-link">3.4 MouseEvent.movementX，MouseEvent.movementY</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-5-mouseevent-screenx，mouseevent-screeny" class="sidebar-link">3.5 MouseEvent.screenX，MouseEvent.screenY</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-6-mouseevent-offsetx，mouseevent-offsety" class="sidebar-link">3.6 MouseEvent.offsetX，MouseEvent.offsetY</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-7-mouseevent-pagex，mouseevent-pagey" class="sidebar-link">3.7 MouseEvent.pageX，MouseEvent.pageY</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_3-8-mouseevent-relatedtarget" class="sidebar-link">3.8 MouseEvent.relatedTarget</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_4-mouseevent-接口的实例方法" class="sidebar-link">4. MouseEvent 接口的实例方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_4-1-mouseevent-getmodifierstate" class="sidebar-link">4.1 MouseEvent.getModifierState()</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_5-wheelevent-接口" class="sidebar-link">5. WheelEvent 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_5-1-实例属性" class="sidebar-link">5.1 实例属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_6-键盘事件" class="sidebar-link">6. 键盘事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_7-keyboardevent-接口" class="sidebar-link">7. KeyboardEvent 接口</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_8-keyboardevent-的实例属性" class="sidebar-link">8. KeyboardEvent 的实例属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_8-1-keyboardevent-altkey，keyboardevent-metakey-ctrlkey，keyboardevent-metakey，keyboardevent-shiftkey" class="sidebar-link">8.1 KeyboardEvent.altKey，KeyboardEvent.metaKey.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_8-2-keyboardevent-code" class="sidebar-link">8.2 KeyboardEvent.code</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_8-3-keyboardevent-key" class="sidebar-link">8.3 KeyboardEvent.key</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_8-4-keyboardevent-location" class="sidebar-link">8.4 KeyboardEvent.location</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_8-5-keyboardevent-repeat" class="sidebar-link">8.5 KeyboardEvent.repeat</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_9-keyboardevent-的实例方法" class="sidebar-link">9. KeyboardEvent 的实例方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_9-1-keyboardevent-getmodifierstate" class="sidebar-link">9.1 KeyboardEvent.getModifierState()</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_10-进度事件" class="sidebar-link">10. 进度事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_11-progressevent-接口" class="sidebar-link">11. ProgressEvent 接口</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_12-拖拉事件" class="sidebar-link">12. 拖拉事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_13-dragevent-接口" class="sidebar-link">13. DragEvent 接口</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_14-datatransfer-接口概述" class="sidebar-link">14. DataTransfer 接口概述</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_15-datatransfer-的实例属性" class="sidebar-link">15.DataTransfer 的实例属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_15-1-datatransfer-dropeffect" class="sidebar-link">15.1 DataTransfer.dropEffect</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_15-2-datatransfer-effectallowed" class="sidebar-link">15.2 DataTransfer.effectAllowed</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_15-3-datatransfer-files" class="sidebar-link">15.3 DataTransfer.files</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_15-4-datatransfer-types" class="sidebar-link">15.4 DataTransfer.types</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_15-5-datatransfer-items" class="sidebar-link">15.5 DataTransfer.items</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_16-datatransfer-的实例方法" class="sidebar-link">16. DataTransfer 的实例方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_16-1-datatransfer-setdata" class="sidebar-link">16.1 DataTransfer.setData()</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_16-2-datatransfer-getdata" class="sidebar-link">16.2 DataTransfer.getData()</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_16-3-datatransfer-cleardata" class="sidebar-link">16.3 DataTransfer.clearData()</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_16-4-datatransfer-setdragimage" class="sidebar-link">16.4 DataTransfer.setDragImage()</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_17-触摸操作概述" class="sidebar-link">17. 触摸操作概述</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_18-touch接口" class="sidebar-link">18. Touch接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_18-1-touch接口概述" class="sidebar-link">18.1 Touch接口概述</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_18-2-touch-接口的实例属性" class="sidebar-link">18.2 Touch 接口的实例属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_19-touchlist-接口" class="sidebar-link">19. TouchList 接口</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_20-touchevent-接口" class="sidebar-link">20. TouchEvent 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_20-1-概述" class="sidebar-link">20.1 概述</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_20-2-实例属性" class="sidebar-link">20.2 实例属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_21-触摸事件的种类" class="sidebar-link">21. 触摸事件的种类</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_22-表单事件的种类" class="sidebar-link">22. 表单事件的种类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_22-1-input-事件" class="sidebar-link">22.1 input 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_22-2-select-事件" class="sidebar-link">22.2 select 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_22-3-change-事件" class="sidebar-link">22.3 Change 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_22-4-invalid-事件" class="sidebar-link">22.4 invalid 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_22-5-reset-事件，submit-事件" class="sidebar-link">22.5 reset 事件，submit 事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_23-资源事件" class="sidebar-link">23. 资源事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_23-1-beforeunload-事件" class="sidebar-link">23.1 beforeunload 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_23-2-unload-事件" class="sidebar-link">23.2 unload 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_23-3-load-事件" class="sidebar-link">23.3 load 事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_24-session-历史事件" class="sidebar-link">24. session 历史事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_24-1-pageshow-事件，pagehide-事件" class="sidebar-link">24.1 pageshow 事件，pagehide 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_24-2-popstate-事件" class="sidebar-link">24.2 popstate 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_24-3-hashchange-事件" class="sidebar-link">24.3 hashchange 事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_25-网页状态事件" class="sidebar-link">25. 网页状态事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_25-1-domcontentloaded-事件" class="sidebar-link">25.1 DOMContentLoaded 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_25-2-readystatechange-事件" class="sidebar-link">25.2 readystatechange 事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_26-窗口事件" class="sidebar-link">26. 窗口事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_26-1-scroll-事件" class="sidebar-link">26.1 scroll 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_26-2-resize-事件" class="sidebar-link">26.2 resize 事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_26-3-fullscreenchange-事件，fullscreenerror-事件" class="sidebar-link">26.3 fullscreenchange 事件，fullscreenerror 事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_27-剪贴板事件" class="sidebar-link">27. 剪贴板事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_28-焦点事件" class="sidebar-link">28. 焦点事件</a></li><li class="sidebar-sub-header"><a href="/doc/dom/010-事件种类.html#_29-参考资料" class="sidebar-link">29. 参考资料</a></li></ul></li></ul> </div> <div class="page"> <div class="content"><p></p><div class="table-of-contents"><ul><li><a href="#_1-鼠标事件">1. 鼠标事件</a></li><li><a href="#_2-mouseevent-接口概述">2. MouseEvent 接口概述</a></li><li><a href="#_3-mouseevent-接口的实例属性">3. MouseEvent 接口的实例属性</a><ul><li><a href="#_3-1-mouseevent-altkey，mouseevent-ctrlkey，mouseevent-metakey，mouseevent-shiftkey">3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</a></li><li><a href="#_3-2-mouseevent-button，mouseevent-buttons">3.2 MouseEvent.button，MouseEvent.buttons</a></li><li><a href="#_3-3-mouseevent-clientx，mouseevent-clienty">3.3 MouseEvent.clientX，MouseEvent.clientY</a></li><li><a href="#_3-4-mouseevent-movementx，mouseevent-movementy">3.4 MouseEvent.movementX，MouseEvent.movementY</a></li><li><a href="#_3-5-mouseevent-screenx，mouseevent-screeny">3.5 MouseEvent.screenX，MouseEvent.screenY</a></li><li><a href="#_3-6-mouseevent-offsetx，mouseevent-offsety">3.6 MouseEvent.offsetX，MouseEvent.offsetY</a></li><li><a href="#_3-7-mouseevent-pagex，mouseevent-pagey">3.7 MouseEvent.pageX，MouseEvent.pageY</a></li><li><a href="#_3-8-mouseevent-relatedtarget">3.8 MouseEvent.relatedTarget</a></li></ul></li><li><a href="#_4-mouseevent-接口的实例方法">4. MouseEvent 接口的实例方法</a><ul><li><a href="#_4-1-mouseevent-getmodifierstate">4.1 MouseEvent.getModifierState()</a></li></ul></li><li><a href="#_5-wheelevent-接口">5. WheelEvent 接口</a><ul><li><a href="#_5-1-实例属性">5.1 实例属性</a></li></ul></li><li><a href="#_6-键盘事件">6. 键盘事件</a></li><li><a href="#_7-keyboardevent-接口">7. KeyboardEvent 接口</a></li><li><a href="#_8-keyboardevent-的实例属性">8. KeyboardEvent 的实例属性</a><ul><li><a href="#_8-1-keyboardevent-altkey，keyboardevent-metakey-ctrlkey，keyboardevent-metakey，keyboardevent-shiftkey">8.1 KeyboardEvent.altKey，KeyboardEvent.metaKey.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey</a></li><li><a href="#_8-2-keyboardevent-code">8.2 KeyboardEvent.code</a></li><li><a href="#_8-3-keyboardevent-key">8.3 KeyboardEvent.key</a></li><li><a href="#_8-4-keyboardevent-location">8.4 KeyboardEvent.location</a></li><li><a href="#_8-5-keyboardevent-repeat">8.5 KeyboardEvent.repeat</a></li></ul></li><li><a href="#_9-keyboardevent-的实例方法">9. KeyboardEvent 的实例方法</a><ul><li><a href="#_9-1-keyboardevent-getmodifierstate">9.1 KeyboardEvent.getModifierState()</a></li></ul></li><li><a href="#_10-进度事件">10. 进度事件</a></li><li><a href="#_11-progressevent-接口">11. ProgressEvent 接口</a></li><li><a href="#_12-拖拉事件">12. 拖拉事件</a></li><li><a href="#_13-dragevent-接口">13. DragEvent 接口</a></li><li><a href="#_14-datatransfer-接口概述">14. DataTransfer 接口概述</a></li><li><a href="#_15-datatransfer-的实例属性">15.DataTransfer 的实例属性</a><ul><li><a href="#_15-1-datatransfer-dropeffect">15.1 DataTransfer.dropEffect</a></li><li><a href="#_15-2-datatransfer-effectallowed">15.2 DataTransfer.effectAllowed</a></li><li><a href="#_15-3-datatransfer-files">15.3 DataTransfer.files</a></li><li><a href="#_15-4-datatransfer-types">15.4 DataTransfer.types</a></li><li><a href="#_15-5-datatransfer-items">15.5 DataTransfer.items</a></li></ul></li><li><a href="#_16-datatransfer-的实例方法">16. DataTransfer 的实例方法</a><ul><li><a href="#_16-1-datatransfer-setdata">16.1 DataTransfer.setData()</a></li><li><a href="#_16-2-datatransfer-getdata">16.2 DataTransfer.getData()</a></li><li><a href="#_16-3-datatransfer-cleardata">16.3 DataTransfer.clearData()</a></li><li><a href="#_16-4-datatransfer-setdragimage">16.4 DataTransfer.setDragImage()</a></li></ul></li><li><a href="#_17-触摸操作概述">17. 触摸操作概述</a></li><li><a href="#_18-touch接口">18. Touch接口</a><ul><li><a href="#_18-1-touch接口概述">18.1 Touch接口概述</a></li><li><a href="#_18-2-touch-接口的实例属性">18.2 Touch 接口的实例属性</a></li></ul></li><li><a href="#_19-touchlist-接口">19. TouchList 接口</a></li><li><a href="#_20-touchevent-接口">20. TouchEvent 接口</a><ul><li><a href="#_20-1-概述">20.1 概述</a></li><li><a href="#_20-2-实例属性">20.2 实例属性</a></li></ul></li><li><a href="#_21-触摸事件的种类">21. 触摸事件的种类</a></li><li><a href="#_22-表单事件的种类">22. 表单事件的种类</a><ul><li><a href="#_22-1-input-事件">22.1 input 事件</a></li><li><a href="#_22-2-select-事件">22.2 select 事件</a></li><li><a href="#_22-3-change-事件">22.3 Change 事件</a></li><li><a href="#_22-4-invalid-事件">22.4 invalid 事件</a></li><li><a href="#_22-5-reset-事件，submit-事件">22.5 reset 事件，submit 事件</a></li></ul></li><li><a href="#_23-资源事件">23. 资源事件</a><ul><li><a href="#_23-1-beforeunload-事件">23.1 beforeunload 事件</a></li><li><a href="#_23-2-unload-事件">23.2 unload 事件</a></li><li><a href="#_23-3-load-事件">23.3 load 事件</a></li></ul></li><li><a href="#_24-session-历史事件">24. session 历史事件</a><ul><li><a href="#_24-1-pageshow-事件，pagehide-事件">24.1 pageshow 事件，pagehide 事件</a></li><li><a href="#_24-2-popstate-事件">24.2 popstate 事件</a></li><li><a href="#_24-3-hashchange-事件">24.3 hashchange 事件</a></li></ul></li><li><a href="#_25-网页状态事件">25. 网页状态事件</a><ul><li><a href="#_25-1-domcontentloaded-事件">25.1 DOMContentLoaded 事件</a></li><li><a href="#_25-2-readystatechange-事件">25.2 readystatechange 事件</a></li></ul></li><li><a href="#_26-窗口事件">26. 窗口事件</a><ul><li><a href="#_26-1-scroll-事件">26.1 scroll 事件</a></li><li><a href="#_26-2-resize-事件">26.2 resize 事件</a></li><li><a href="#_26-3-fullscreenchange-事件，fullscreenerror-事件">26.3 fullscreenchange 事件，fullscreenerror 事件</a></li></ul></li><li><a href="#_27-剪贴板事件">27. 剪贴板事件</a></li><li><a href="#_28-焦点事件">28. 焦点事件</a></li><li><a href="#_29-参考资料">29. 参考资料</a></li></ul></div><p></p> <p>[TOC]</p> <h1 id="十、事件种类"><a href="#十、事件种类" aria-hidden="true" class="header-anchor">#</a> 十、事件种类</h1> <h2 id="_1-鼠标事件"><a href="#_1-鼠标事件" aria-hidden="true" class="header-anchor">#</a> 1. 鼠标事件</h2> <p>鼠标事件指与鼠标相关的事件，继承了<code>MouseEvent</code>接口。具体的事件主要有以下一些。</p> <blockquote><ul><li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。chrome浏览器右键、滚轮不会触发</li> <li><code>dblclick</code>：在同一个元素上双击鼠标时触发。</li> <li><code>mousedown</code>：按下鼠标键时触发。</li> <li><code>mouseup</code>：释放按下的鼠标键时触发。</li> <li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li> <li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</li> <li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</li> <li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</li> <li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</li> <li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。</li> <li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li></ul></blockquote> <p><code>click</code>事件指的是，用户在同一个位置先完成<code>mousedown</code>动作，再完成<code>mouseup</code>动作。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p> <p><code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p> <p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
    &lt;li&gt;item 1&lt;/li&gt;
    &lt;li&gt;item 2&lt;/li&gt;
    &lt;li&gt;item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    // 进入 ul 节点以后，mouseenter 事件只会触发一次
    // 以后只要鼠标在节点内移动，都不会再触发这个事件
    // event.target 是 ul 节点
    var ul = document.querySelector('ul');
    ul.addEventListener('mouseenter', function (event) {
        event.target.style.color = 'red';
        setTimeout(function () { event.target.style.color = ''; }, 500);
    }, false);
    // 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次
  // event.target 是 li 节点
    ul.addEventListener('mouseover', function (event) {
        event.target.style.color = 'blue';
        setTimeout(function () { event.target.style.color = ''; }, 500);
    }, false);
&lt;/script&gt;
</code></pre></div><p>上面代码中，在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p> <p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而<code>mouseout</code>事件会触发。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
    &lt;li&gt;item 1&lt;/li&gt;
    &lt;li&gt;item 2&lt;/li&gt;
    &lt;li&gt;item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    // 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件
    // 只有离开 ul 节点时，触发一次 mouseleave
    // event.target 是 ul 节点
    var ul = document.querySelector('ul');
    ul.addEventListener('mouseleave', function (event) {
        event.target.style.color = 'red';
        setTimeout(function () { event.target.style.color = ''; }, 500);
    }, false);
    // 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次
  // event.target 是 li 节点
    ul.addEventListener('mouseout', function (event) {
        event.target.style.color = 'yellow';
        setTimeout(function () { event.target.style.color = ''; }, 500);
    }, false);
&lt;/script&gt;
</code></pre></div><p>上面代码中，在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p> <h2 id="_2-mouseevent-接口概述"><a href="#_2-mouseevent-接口概述" aria-hidden="true" class="header-anchor">#</a> 2. MouseEvent 接口概述</h2> <p><code>MouseEvent</code>接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是<code>MouseEvent</code>实例。此外，滚轮事件和拖拉事件也是<code>MouseEvent</code>实例。</p> <p><code>MouseEvent</code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法。它还有自己的属性和方法。</p> <p>浏览器原生提供一个<code>MouseEvent</code>构造函数，用于新建一个<code>MouseEvent</code>实例。</p> <div class="language- extra-class"><pre class="language-text"><code>var event = new MouseEvent(type, options);
</code></pre></div><p><code>MouseEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p> <blockquote><ul><li><code>screenX</code>：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li> <li><code>screenY</code>：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与<code>screenX</code>相同。</li> <li><code>clientX</code>：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li> <li><code>clientY</code>：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与<code>clientX</code>相同。</li> <li><code>ctrlKey</code>：布尔值，是否同时按下了 Ctrl 键，默认值为<code>false</code>。</li> <li><code>shiftKey</code>：布尔值，是否同时按下了 Shift 键，默认值为<code>false</code>。</li> <li><code>altKey</code>：布尔值，是否同时按下 Alt 键，默认值为<code>false</code>。</li> <li><code>metaKey</code>：布尔值，是否同时按下 Meta 键，默认值为<code>false</code>。</li> <li><code>button</code>：数值，表示按下了哪一个鼠标按键，默认值为<code>0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code>1</code>表示按下辅助键（通常是鼠标的中间键），<code>2</code>表示按下次要键（通常是鼠标的右键）。</li> <li><code>buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为<code>0</code>（没有按下任何键）。<code>1</code>（二进制<code>001</code>）表示按下主键（通常是左键），<code>2</code>（二进制<code>010</code>）表示按下次要键（通常是右键），<code>4</code>（二进制<code>100</code>）表示按下辅助键（通常是中间键）。因此，如果返回<code>3</code>（二进制<code>011</code>）就表示同时按下了左键和右键。</li> <li><code>relatedTarget</code>：节点对象，表示事件的相关节点，默认为<code>null</code>。<code>mouseenter</code>和<code>mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code>mouseout</code>和<code>mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li></ul></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;input id=&quot;btn&quot; type=&quot;checkbox&quot;&gt;
&lt;script&gt;
    var event = new MouseEvent('click', {
        'bubbles': true, 'cancelable': true
    });
    var cb = document.getElementById('btn');
    cb.dispatchEvent(event);
&lt;/script&gt;
</code></pre></div><p>上面代码生成一个鼠标点击事件，并触发该事件。</p> <h2 id="_3-mouseevent-接口的实例属性"><a href="#_3-mouseevent-接口的实例属性" aria-hidden="true" class="header-anchor">#</a> 3. MouseEvent 接口的实例属性</h2> <h3 id="_3-1-mouseevent-altkey，mouseevent-ctrlkey，mouseevent-metakey，mouseevent-shiftkey"><a href="#_3-1-mouseevent-altkey，mouseevent-ctrlkey，mouseevent-metakey，mouseevent-shiftkey" aria-hidden="true" class="header-anchor">#</a> 3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</h3> <p><code>MouseEvent.altKey</code>、<code>MouseEvent.ctrlKey</code>、<code>MouseEvent.metaKey</code>、<code>MouseEvent.shiftKey</code>这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</p> <blockquote><ul><li><code>altKey</code>属性：Alt 键</li> <li><code>ctrlKey</code>属性：Ctrl 键</li> <li><code>metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li> <li><code>shiftKey</code>属性：Shift 键</li></ul></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;
&lt;script&gt;
    function showKey(e) {
        console.log('ALT key pressed: ' + e.altKey);
        console.log('CTRL key pressed: ' + e.ctrlKey);
        console.log('META key pressed: ' + e.metaKey);
        console.log('SHIFT key pressed: ' + e.shiftKey);
    }
    var btn = document.getElementById('btn');
    btn.onclick = showKey;
&lt;/script&gt;
</code></pre></div><p>上面的代码中， 鼠标点击按钮会输出是否同时按下对应的键。</p> <h3 id="_3-2-mouseevent-button，mouseevent-buttons"><a href="#_3-2-mouseevent-button，mouseevent-buttons" aria-hidden="true" class="header-anchor">#</a> 3.2 MouseEvent.button，MouseEvent.buttons</h3> <ul><li><p><code>MouseEvent.button</code>属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。</p> <blockquote><p>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code>mousemove</code>事件）。</p> <p>1：按下辅助键（通常是中键或者滚轮键）。</p> <p>2：按下次键（通常是右键）。</p></blockquote></li> <li><p><code>MouseEvent.buttons</code>属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。</p> <blockquote><p>1：二进制为<code>001</code>（十进制的1），表示按下左键。</p> <p>2：二进制为<code>010</code>（十进制的2），表示按下右键。</p> <p>4：二进制为<code>100</code>（十进制的4），表示按下中键或滚轮键。</p></blockquote> <p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;
&lt;script&gt;
    //去掉默认的contextmenu事件，否则会和右键事件同时出现。
    document.oncontextmenu = function(e){ e.preventDefault(); };
    function showKey(e) {
        console.log('button : ' + e.button);
        console.log('buttons : ' + e.buttons);
    }
    var btn = document.getElementById('btn');
    //   btn.onclick = showKey;
    //     btn.onmouseup = showKey;
    btn.onmousedown = showKey;
&lt;/script&gt;
</code></pre></div><p>上面代码测试鼠标的按键。</p> <h3 id="_3-3-mouseevent-clientx，mouseevent-clienty"><a href="#_3-3-mouseevent-clientx，mouseevent-clienty" aria-hidden="true" class="header-anchor">#</a> 3.3 MouseEvent.clientX，MouseEvent.clientY</h3> <ul><li><code>MouseEvent.clientX</code>属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素）</li> <li><code>MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是只读属性</li></ul> <p>这两个属性还分别有一个别名<code>MouseEvent.x</code>和<code>MouseEvent.y</code></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;
&lt;script&gt;
    function showKey(e) {
        console.log(&quot;clientX value:&quot;, e.clientX);
        console.log(&quot;clientY value: &quot;, e.clientY);
        console.log(&quot;x value:&quot;, e.x);
        console.log(&quot;y value: &quot;, e.y);
    }
    var btn = document.getElementById('btn');
    btn.onmousedown = showKey;
&lt;/script&gt;
</code></pre></div><h3 id="_3-4-mouseevent-movementx，mouseevent-movementy"><a href="#_3-4-mouseevent-movementx，mouseevent-movementy" aria-hidden="true" class="header-anchor">#</a> 3.4 MouseEvent.movementX，MouseEvent.movementY</h3> <ul><li><code>MouseEvent.movementX</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的水平距离（单位像素）,只读</li> <li><code>MouseEvent.movementY</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的垂直距离（单位像素）,只读</li></ul> <p>数值上他们等于下面的计算公式：</p> <div class="language- extra-class"><pre class="language-text"><code>currentEvent.movementX = currentEvent.screenX - previousEvent.screenX
currentEvent.movementY = currentEvent.screenY - previousEvent.screenY
&lt;button id=&quot;btn&quot;&gt;按钮11111111&lt;/button&gt;
&lt;script&gt;
    function showKey(e) {
        console.log(&quot;movementX :&quot;, e.movementX);
        console.log(&quot;movementY : &quot;, e.movementY );      
    }
    var btn = document.getElementById('btn');
    btn.onmousemove = showKey;
&lt;/script&gt;
</code></pre></div><p>上面的代码中，鼠标在按钮上移动的时候可以发现值的变化。</p> <h3 id="_3-5-mouseevent-screenx，mouseevent-screeny"><a href="#_3-5-mouseevent-screenx，mouseevent-screeny" aria-hidden="true" class="header-anchor">#</a> 3.5 MouseEvent.screenX，MouseEvent.screenY</h3> <ul><li><code>MouseEvent.screenX</code>属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），只读</li> <li><code>MouseEvent.screenY</code>属性返回垂直坐标，只读属性</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id=&quot;btn&quot;&gt;按钮11111111&lt;/button&gt;
&lt;script&gt;
    function showKey(e) {
        console.log(&quot;screenX:&quot;, e.screenX );
        console.log(&quot;screenY:&quot;, e.screenY);      
    }
    var btn = document.getElementById('btn');
    btn.onmousedown = showKey;
&lt;/script&gt;
</code></pre></div><h3 id="_3-6-mouseevent-offsetx，mouseevent-offsety"><a href="#_3-6-mouseevent-offsetx，mouseevent-offsety" aria-hidden="true" class="header-anchor">#</a> 3.6 MouseEvent.offsetX，MouseEvent.offsetY</h3> <ul><li><code>MouseEvent.offsetX</code>属性返回鼠标位置与目标节点左侧的<code>padding</code>边缘的水平距离（单位像素）,只读</li> <li><code>MouseEvent.offsetY</code>属性返回与目标节点上方的<code>padding</code>边缘的垂直距离，只读</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
    p {
        width: 100px; height: 100px; padding: 100px; border: 1px solid;
    }
&lt;/style&gt;
&lt;p&gt;Hello&lt;/p&gt;
&lt;script&gt;
    var p = document.querySelector('p');
    p.addEventListener(
        'click',
        function (e) {
            console.log(e.offsetX);
            console.log(e.offsetY);
        },
        false
    );
&lt;/script&gt;
</code></pre></div><p>上面代码中，鼠标如果在<code>p</code>元素的中心位置点击，会返回<code>150 150</code>。因此中心位置距离左侧和上方的<code>padding</code>边缘，等于<code>padding</code>的宽度（100像素）加上元素内容区域一半的宽度（50像素）。</p> <h3 id="_3-7-mouseevent-pagex，mouseevent-pagey"><a href="#_3-7-mouseevent-pagex，mouseevent-pagey" aria-hidden="true" class="header-anchor">#</a> 3.7 MouseEvent.pageX，MouseEvent.pageY</h3> <ul><li><code>MouseEvent.pageX</code>属性返回鼠标位置与文档左侧边缘的距离（单位像素）,只读</li> <li><code>MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）,只读</li></ul> <p>它们的返回值都包括文档不可见的部分。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
    body { height: 2000px; border: 5px solid red; }
&lt;/style&gt;
&lt;p&gt;Hello&lt;/p&gt;
&lt;script&gt;
    document.body.addEventListener(
        'click',
        function (e) {
            console.log(e.pageX);
            console.log(e.pageY);
        },
        false
    );
&lt;/script&gt;
</code></pre></div><p>上面代码中，页面高度为2000像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的<code>pageY</code>值会接近2000。</p> <h3 id="_3-8-mouseevent-relatedtarget"><a href="#_3-8-mouseevent-relatedtarget" aria-hidden="true" class="header-anchor">#</a> 3.8 MouseEvent.relatedTarget</h3> <p><code>MouseEvent.relatedTarget</code>属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回<code>null</code>。该属性只读。</p> <p>下表列出不同事件的<code>target</code>属性值和<code>relatedTarget</code>属性值义。</p> <table><thead><tr><th style="text-align:left">事件名称</th> <th style="text-align:left">target 属性</th> <th style="text-align:left">relatedTarget 属性</th></tr></thead> <tbody><tr><td style="text-align:left">focusin</td> <td style="text-align:left">接受焦点的节点</td> <td style="text-align:left">丧失焦点的节点</td></tr> <tr><td style="text-align:left">focusout</td> <td style="text-align:left">丧失焦点的节点</td> <td style="text-align:left">接受焦点的节点</td></tr> <tr><td style="text-align:left">mouseenter</td> <td style="text-align:left">将要进入的节点</td> <td style="text-align:left">将要离开的节点</td></tr> <tr><td style="text-align:left">mouseleave</td> <td style="text-align:left">将要离开的节点</td> <td style="text-align:left">将要进入的节点</td></tr> <tr><td style="text-align:left">mouseout</td> <td style="text-align:left">将要离开的节点</td> <td style="text-align:left">将要进入的节点</td></tr> <tr><td style="text-align:left">mouseover</td> <td style="text-align:left">将要进入的节点</td> <td style="text-align:left">将要离开的节点</td></tr> <tr><td style="text-align:left">dragenter</td> <td style="text-align:left">将要进入的节点</td> <td style="text-align:left">将要离开的节点</td></tr> <tr><td style="text-align:left">dragexit</td> <td style="text-align:left">将要离开的节点</td> <td style="text-align:left">将要进入的节点</td></tr></tbody></table> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;outer&quot; style=&quot;height:100px;width:100px;border:1px solid black;&quot;&gt;outer
    &lt;div id=&quot;inner&quot; style=&quot;height:50px;width:50px;border:1px solid black;&quot;&gt;inner&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var inner = document.getElementById('inner');
    inner.addEventListener('mouseover', function (event) {
        console.log('进入' + event.target.id + ' 离开' + event.relatedTarget.id);
    }, false);
    inner.addEventListener('mouseenter', function (event) {
        console.log('进入' + event.target.id + ' 离开' + event.relatedTarget.id);
    });
    inner.addEventListener('mouseout', function () {
        console.log('离开' + event.target.id + ' 进入' + event.relatedTarget.id);
    });
    inner.addEventListener(&quot;mouseleave&quot;, function (){
        console.log('离开' + event.target.id + ' 进入' + event.relatedTarget.id);
    });
    // 鼠标从 outer 进入inner，输出
    // 进入inner 离开outer
    // 进入inner 离开outer

    // 鼠标从 inner进入 outer，输出
    // 离开inner 进入outer
    // 离开inner 进入outer
&lt;/script&gt;
</code></pre></div><h2 id="_4-mouseevent-接口的实例方法"><a href="#_4-mouseevent-接口的实例方法" aria-hidden="true" class="header-anchor">#</a> 4. MouseEvent 接口的实例方法</h2> <h3 id="_4-1-mouseevent-getmodifierstate"><a href="#_4-1-mouseevent-getmodifierstate" aria-hidden="true" class="header-anchor">#</a> 4.1 MouseEvent.getModifierState()</h3> <p><code>MouseEvent.getModifierState</code>方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#Modifier_keys_on_Gecko" target="_blank" rel="noopener noreferrer">功能键<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id=&quot;btn&quot;&gt;按钮11111111&lt;/button&gt;
&lt;script&gt;
    function showKey(e) {
        console.log(e.getModifierState('CapsLock'));  
    }
    var btn = document.getElementById('btn');
    btn.onclick = showKey;
&lt;/script&gt;
</code></pre></div><p>上面的代码可以了解用户是否按下了大写键。</p> <h2 id="_5-wheelevent-接口"><a href="#_5-wheelevent-接口" aria-hidden="true" class="header-anchor">#</a> 5. WheelEvent 接口</h2> <p>WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个<code>wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p> <p>浏览器原生提供<code>WheelEvent()</code>构造函数，用来生成<code>WheelEvent</code>实例。</p> <div class="language- extra-class"><pre class="language-text"><code>var wheelEvent = new WheelEvent(type, options);
</code></pre></div><p><code>WheelEvent()</code>构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是<code>wheel</code>。第二个参数是事件的配置对象。该对象的属性除了<code>Event</code>、<code>UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p> <blockquote><ul><li><code>deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li> <li><code>deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li> <li><code>deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li> <li><code>deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code>0</code>表示滚动单位为像素，<code>1</code>表示单位为行，<code>2</code>表示单位为页，默认为<code>0</code>。</li></ul></blockquote> <h3 id="_5-1-实例属性"><a href="#_5-1-实例属性" aria-hidden="true" class="header-anchor">#</a> 5.1 实例属性</h3> <p><code>WheelEvent</code>事件实例除了具有<code>Event</code>和<code>MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p> <p>下面的属性都是只读属性</p> <blockquote><p><code>WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</p> <p><code>WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</p> <p><code>WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</p> <p><code>WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code>0</code>是像素，<code>1</code>是行，<code>2</code>是页。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id=&quot;btn&quot;&gt;按钮11111111&lt;/button&gt;
&lt;script&gt;
    function showKey(e) {
        console.log(&quot;deltaX &quot;, e.deltaX); // deltaX  30
        console.log(&quot;deltaY &quot;, e.deltaY); // deltaY  50
        console.log(&quot;deltaMode &quot;, e.deltaMode );  // deltaMode  0
    }
    var btn = document.getElementById('btn');
    var wheelEvent = new WheelEvent(&quot;wheel&quot;, {&quot;deltaX&quot;: 30,deltaY: 50});
    btn.onwheel  = showKey;
    btn.dispatchEvent(wheelEvent);
&lt;/script&gt;
</code></pre></div><h2 id="_6-键盘事件"><a href="#_6-键盘事件" aria-hidden="true" class="header-anchor">#</a> 6. 键盘事件</h2> <p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p> <ul><li><code>keydown</code>：按下键盘时触发。</li> <li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。</li> <li><code>keyup</code>：松开键盘时触发该事件。</li></ul> <p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p> <ol><li>keydown</li> <li>keypress</li> <li>keydown</li> <li>keypress</li> <li>…（重复以上过程）</li> <li>keyup</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;input id=&quot;btn&quot; type=&quot;text&quot;&gt;
&lt;script&gt;
    function showKey(e) { console.log(e.type);   }
    var btn = document.getElementById('btn');
    btn.onclick  = showKey;
    btn.onkeydown = showKey;
    btn.onkeypress = showKey;
    btn.onkeyup = showKey;
&lt;/script&gt;
</code></pre></div><p>上面的代码中，在输入框中输入一个字母的时候输出：<code>keydown</code>、<code>keypress</code>、<code>keyup</code></p> <p>在输入框按下shift键的时候输出：<code>keydown</code>、<code>keyup</code></p> <h2 id="_7-keyboardevent-接口"><a href="#_7-keyboardevent-接口" aria-hidden="true" class="header-anchor">#</a> 7. KeyboardEvent 接口</h2> <p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口继承了<code>Event</code>接口，并且定义了自己的实例属性和实例方法。</p> <p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p> <div class="language- extra-class"><pre class="language-text"><code>new KeyboardEvent(type, options)
</code></pre></div><p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p> <ul><li><code>key</code>：字符串，当前按下的键，默认为空字符串。</li> <li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li> <li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li> <li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li> <li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li> <li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li> <li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li> <li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li></ul> <h2 id="_8-keyboardevent-的实例属性"><a href="#_8-keyboardevent-的实例属性" aria-hidden="true" class="header-anchor">#</a> 8. KeyboardEvent 的实例属性</h2> <h3 id="_8-1-keyboardevent-altkey，keyboardevent-metakey-ctrlkey，keyboardevent-metakey，keyboardevent-shiftkey"><a href="#_8-1-keyboardevent-altkey，keyboardevent-metakey-ctrlkey，keyboardevent-metakey，keyboardevent-shiftkey" aria-hidden="true" class="header-anchor">#</a> 8.1 KeyboardEvent.altKey，KeyboardEvent.metaKey.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey</h3> <p>以下属性都是只读属性，返回一个布尔值，表示是否按下对应的键。</p> <ul><li><code>KeyboardEvent.altKey</code>：是否按下 Alt 键</li> <li><code>KeyboardEvent.ctrlKey</code>：是否按下 Ctrl 键</li> <li><code>KeyboardEvent.metaKey</code>：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</li> <li><code>KeyboardEvent.shiftKey</code>：是否按下 Shift 键</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function showChar(e){
        console.log(&quot;ALT: &quot; + e.altKey);
        console.log(&quot;CTRL: &quot; + e.ctrlKey);
        console.log(&quot;Meta: &quot; + e.metaKey);
        console.log(&quot;Meta: &quot; + e.shiftKey);
    }
    document.body.addEventListener('keyup', showChar, false);
&lt;/script&gt;
</code></pre></div><h3 id="_8-2-keyboardevent-code"><a href="#_8-2-keyboardevent-code" aria-hidden="true" class="header-anchor">#</a> 8.2 KeyboardEvent.code</h3> <ul><li><code>KeyboardEvent.code</code>属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。</li></ul> <p>下面是一些常用键的字符串形式，其他键请查<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code#Code_values" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <blockquote><p>数字键0 - 9：返回<code>digital0</code> - <code>digital9</code></p> <p>字母键A - z：返回<code>KeyA</code> - <code>KeyZ</code></p> <p>功能键F1 - F12：返回 <code>F1</code> - <code>F12</code></p> <p>方向键：返回<code>ArrowDown</code>、<code>ArrowUp</code>、<code>ArrowLeft</code>、<code>ArrowRight</code></p> <p>Alt 键：返回<code>AltLeft</code>或<code>AltRight</code></p> <p>Shift 键：返回<code>ShiftLeft</code>或<code>ShiftRight</code></p> <p>Ctrl 键：返回<code>ControLeft</code>或<code>ControlRight</code></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function showChar(e){
        console.log(&quot;code: &quot; + e.code);
    }
    document.body.addEventListener('keyup', showChar, false);
&lt;/script&gt;
</code></pre></div><p>上面的代码执行后，在页面上按键盘后，会输出对应按键的code</p> <h3 id="_8-3-keyboardevent-key"><a href="#_8-3-keyboardevent-key" aria-hidden="true" class="header-anchor">#</a> 8.3 KeyboardEvent.key</h3> <ul><li><code>KeyboardEvent.key</code>属性返回一个字符串，表示按下的键名。该属性只读。</li></ul> <p>如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。</p> <p>如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1～F12，NumLock，Scroll 等。</p> <p>如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回<code>a</code>；按下 Shift + a，则返回大写的<code>A</code>。</p> <p>如果无法识别键名，返回字符串<code>Unidentified</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function showChar(e){ console.log(&quot;key: &quot; + e.key); }
    document.body.addEventListener('keyup', showChar, false);
&lt;/script&gt;
</code></pre></div><h3 id="_8-4-keyboardevent-location"><a href="#_8-4-keyboardevent-location" aria-hidden="true" class="header-anchor">#</a> 8.4 KeyboardEvent.location</h3> <ul><li><p><code>KeyboardEvent.location</code>属性返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值</p> <blockquote><p>0：处在键盘的主区域，或者无法判断处于哪一个区域。</p> <p>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p> <p>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p> <p>3：处在数字小键盘。</p></blockquote></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function showChar(e){ console.log(&quot;location: &quot; + e.location); }
    document.body.addEventListener('keyup', showChar, false);
&lt;/script&gt;
</code></pre></div><p>上面的代码可以监控到按键在键盘的位置。</p> <h3 id="_8-5-keyboardevent-repeat"><a href="#_8-5-keyboardevent-repeat" aria-hidden="true" class="header-anchor">#</a> 8.5 KeyboardEvent.repeat</h3> <p><code>KeyboardEvent.repeat</code>返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发<code>keydown</code>和<code>keypress</code>事件，直到用户松开手为止。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function showChar(e){ console.log(&quot;repeat: &quot; + e.repeat); }
    document.body.addEventListener('keydown', showChar, false);
    // document.body.addEventListener('keypress', showChar, false);
    // document.body.addEventListener('keyup', showChar, false);
&lt;/script&gt;
</code></pre></div><p>上面的代码执行后，在页面上按住一个键不放就出测试出repeat，</p> <p>注意监听<code>keyup</code>不会触发<code>repeat</code>。</p> <h2 id="_9-keyboardevent-的实例方法"><a href="#_9-keyboardevent-的实例方法" aria-hidden="true" class="header-anchor">#</a> 9. KeyboardEvent 的实例方法</h2> <h3 id="_9-1-keyboardevent-getmodifierstate"><a href="#_9-1-keyboardevent-getmodifierstate" aria-hidden="true" class="header-anchor">#</a> 9.1 KeyboardEvent.getModifierState()</h3> <p><code>KeyboardEvent.getModifierState()</code>方法返回一个布尔值，表示是否按下或激活指定的功能键。</p> <p>它的常用参数如下:</p> <blockquote><ul><li><code>Alt</code>：Alt 键</li> <li><code>CapsLock</code>：大写锁定键</li> <li><code>Control</code>：Ctrl 键</li> <li><code>Meta</code>：Meta 键</li> <li><code>NumLock</code>：数字键盘开关键</li> <li><code>Shift</code>：Shift 键</li></ul></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function showChar(e){ 
        if (
            event.getModifierState('Control') +
            event.getModifierState('Alt') +
            event.getModifierState('Meta') == 3
        ) {
            console.log('Control Alt Meta')
        } else { console.log('没有') }
    }
    document.body.addEventListener('keydown', showChar, false);
&lt;/script&gt;
</code></pre></div><h2 id="_10-进度事件"><a href="#_10-进度事件" aria-hidden="true" class="header-anchor">#</a> 10. 进度事件</h2> <p>进度事件用来描述资源加载的进度，主要由 AJAX 请求、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种事件:</p> <blockquote><ul><li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</li> <li><code>error</code>：由于错误导致外部资源无法加载时触发。</li> <li><code>load</code>：外部资源加载成功时触发。</li> <li><code>loadstart</code>：外部资源开始加载时触发。</li> <li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。</li> <li><code>progress</code>：外部资源加载过程中不断触发。</li> <li><code>timeout</code>：加载超时时触发。</li></ul></blockquote> <p>注意，除了资源下载，文件上传也存在这些事件。</p> <div class="language- extra-class"><pre class="language-text"><code>image.addEventListener('load', function (event) {
  image.classList.add('finished');
});

image.addEventListener('error', function (event) {
  image.style.display = 'none';
});
</code></pre></div><p>上面代码在图片元素加载完成后，为图片元素添加一个<code>finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p> <p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code>load</code>和<code>error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code>complete</code>属性先判断一下是否加载完成。</p> <div class="language- extra-class"><pre class="language-text"><code>function loaded() {
  // ...
}

if (image.complete) {
  loaded();
} else {
  image.addEventListener('load', loaded);
}
</code></pre></div><p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code>error</code>事件的监听函数最好放在<code>&lt;img&gt;</code>元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;img src=&quot;/wrong/url&quot; onerror=&quot;this.style.display='none';&quot; /&gt;
</code></pre></div><p><code>loadend</code>事件的监听函数，可以用来取代<code>abort</code>事件、<code>load</code>事件、<code>error</code>事件的监听函数，因为它总是在这些事件之后发生。</p> <div class="language- extra-class"><pre class="language-text"><code>req.addEventListener('loadend', loadEnd, false);

function loadEnd(e) {
  console.log('传输结束，成功失败未知');
}
</code></pre></div><p><code>loadend</code>事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p> <p>另外，<code>error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code>error</code>事件，不会触发父元素的<code>error</code>事件监听函数。</p> <h2 id="_11-progressevent-接口"><a href="#_11-progressevent-接口" aria-hidden="true" class="header-anchor">#</a> 11. ProgressEvent 接口</h2> <p><code>ProgressEvent</code>接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<code>&lt;img&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源加载。进度相关的事件都继承了这个接口。</p> <p>浏览器原生提供了<code>ProgressEvent()</code>构造函数，用来生成事件实例。</p> <div class="language- extra-class"><pre class="language-text"><code>new ProgressEvent(type, options)
</code></pre></div><p><code>ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code>Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p> <blockquote><ul><li><code>lengthComputable</code>：布尔值，表示加载的总量是否可以计算，默认是<code>false</code>。</li> <li><code>loaded</code>：整数，表示已经加载的量，默认是<code>0</code>。</li> <li><code>total</code>：整数，表示需要加载的总量，默认是<code>0</code>。</li></ul></blockquote> <p><code>ProgressEvent</code>具有对应的实例属性。</p> <blockquote><ul><li><code>ProgressEvent.lengthComputable</code></li> <li><code>ProgressEvent.loaded</code></li> <li><code>ProgressEvent.total</code></li></ul></blockquote> <p>如果<code>ProgressEvent.lengthComputable</code>为<code>false</code>，<code>ProgressEvent.total</code>实际上是没有意义的。</p> <p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    var p = new ProgressEvent('load', {
        lengthComputable: true,
        loaded: 30,
        total: 100,
    });
    document.body.addEventListener('load', function (e) {
        console.log('已经加载：' + (e.loaded / e.total) * 100 + '%');
    });
    document.body.dispatchEvent(p);
&lt;/script&gt;
</code></pre></div><p>上面代码先构造一个<code>load</code>事件，抛出后被监听函数捕捉到。</p> <p>下面是一个实际的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var xhr = new XMLHttpRequest();

xhr.addEventListener('progress', updateProgress, false);
xhr.addEventListener('load', transferComplete, false);
xhr.addEventListener('error', transferFailed, false);
xhr.addEventListener('abort', transferCanceled, false);

xhr.open();
function updateProgress(e) {
  if (e.lengthComputable) {
    var percentComplete = e.loaded / e.total;
  } else {
    console.log('不能计算进度');
  }
}

function transferComplete(e) {
  console.log('传输结束');
}

function transferFailed(evt) {
  console.log('传输过程中发生错误');
}

function transferCanceled(evt) {
  console.log('用户取消了传输');
}
</code></pre></div><p>上面是下载过程的进度事件，还存在上传过程的进度事件。这时所有监听函数都要放在<code>XMLHttpRequest.upload</code>对象上面。</p> <div class="language- extra-class"><pre class="language-text"><code>var xhr = new XMLHttpRequest();

xhr.upload.addEventListener('progress', updateProgress, false);
xhr.upload.addEventListener('load', transferComplete, false);
xhr.upload.addEventListener('error', transferFailed, false);
xhr.upload.addEventListener('abort', transferCanceled, false);

xhr.open();
</code></pre></div><h2 id="_12-拖拉事件"><a href="#_12-拖拉事件" aria-hidden="true" class="header-anchor">#</a> 12. 拖拉事件</h2> <p>拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p> <p>拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div draggable=&quot;true&quot;&gt;
  此区域可拖拉
&lt;/div&gt;
</code></pre></div><p><code>draggable</code>属性可用于任何元素节点，但是图片（<code>&lt;img&gt;</code>）和链接（<code>&lt;a&gt;</code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p> <p>注意，一旦某个元素节点的<code>draggable</code>属性设为<code>true</code>，就无法再用鼠标选中该节点内部的文字或子节点了。</p> <p>当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</p> <blockquote><ul><li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li> <li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li> <li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li> <li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li> <li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li> <li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li> <li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li></ul></blockquote> <p>下面的例子展示，如何动态改变被拖动节点的背景色。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;one&quot; draggable=&quot;true&quot;&gt;可拖动div&lt;/div&gt;
&lt;div&gt; &lt;a href=&quot;&quot;&gt;dadasdasdsadasdasds&lt;/a&gt; &lt;/div&gt;
&lt;script&gt;
    var div = document.getElementById(&quot;one&quot;);
    div.addEventListener('dragstart', function (e) {
        this.style.backgroundColor = 'red';
    }, false);
    div.addEventListener('dragend', function (e) {
        this.style.backgroundColor = 'green';
    }, false);
&lt;/script&gt;
</code></pre></div><p>上面代码中，<code>div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p> <p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt; .dropzone {border: 1px solid; min-height: 100px;} &lt;/style&gt;
&lt;div class=&quot;dropzone&quot;&gt;
    &lt;div id=&quot;dragged&quot; draggable=&quot;true&quot;&gt; 该节点可拖拉 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var dragged = document.getElementById(&quot;dragged&quot;);
    // 开始拖动时触发：拖动的节点字体颜色变红，背景色变通欧明
    document.addEventListener('dragstart', function (event) {
        dragged = event.target;	// 保存被拖拉节点
        event.target.style.opacity = 0.5;// 被拖拉节点的背景色变透明
        event.target.style.color = &quot;yellow&quot;;
    }, false);
    // 拖动结束后触发：拖动的节点字体颜色恢复，背景色恢复
    document.addEventListener('dragend', function (event) {
        event.target.style.opacity = '';// 被拖拉节点的背景色恢复正常
        event.target.style.color = &quot;&quot;;
    }, false);
    // 拖拉到当前节点上方时，在当前节点上持续触发
    document.addEventListener('dragover', function (event) {
        event.preventDefault();// 防止拖拉效果被重置，允许被拖拉的节点放入目标节点
    }, false);
    // 拖拉进入当前节点时，在当前节点上触发一次
    document.addEventListener('dragenter', function (event) {
        // 目标节点的背景色变紫色
        // 由于该事件会冒泡，所以要过滤节点
        if (event.target.className === 'dropzone') {
            event.target.style.background = 'purple';
        }
    }, false);
    // 拖拉操作离开当前节点范围时，在当前节点上触发
    document.addEventListener('dragleave', function( event ) {
        // 目标节点的背景色恢复原样
        if (event.target.className === 'dropzone') {
            event.target.style.background = '';
        }
    }, false);
    // 被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发
    document.addEventListener('drop', function( event ) {
        // 防止事件默认行为（比如某些元素节点上可以打开链接），
        event.preventDefault();
        if (event.target.className === 'dropzone') {
            // 恢复目标节点背景色
            event.target.style.background = '';
            // 将被拖拉节点插入目标节点
            dragged.parentNode.removeChild(dragged);
            event.target.appendChild( dragged );
        }
    }, false);
&lt;/script&gt;
</code></pre></div><p>关于拖拉事件，有以下几个注意点:</p> <blockquote><ul><li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li> <li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li> <li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li></ul></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;div ondragover=&quot;return false&quot;&gt;
&lt;div ondragover=&quot;event.preventDefault()&quot;&gt;
</code></pre></div><p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在<code>div</code>节点上放下被拖拉的节点。</p> <h2 id="_13-dragevent-接口"><a href="#_13-dragevent-接口" aria-hidden="true" class="header-anchor">#</a> 13. DragEvent 接口</h2> <p>拖拉事件都继承了<code>DragEvent</code>接口，这个接口又继承了<code>MouseEvent</code>接口和<code>Event</code>接口。</p> <p>浏览器原生提供一个<code>DragEvent()</code>构造函数，用来生成拖拉事件的实例对象。</p> <div class="language- extra-class"><pre class="language-text"><code>new DragEvent(type, options)
</code></pre></div><p><code>DragEvent()</code>构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。配置对象除了接受<code>MouseEvent</code>接口和<code>Event</code>接口的配置属性，还可以设置<code>dataTransfer</code>属性要么是<code>null</code>，要么是一个<code>DataTransfer</code>接口的实例。</p> <p><code>DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据</p> <h2 id="_14-datatransfer-接口概述"><a href="#_14-datatransfer-接口概述" aria-hidden="true" class="header-anchor">#</a> 14. DataTransfer 接口概述</h2> <p>所有拖拉事件的实例都有一个<code>DragEvent.dataTransfer</code>属性，用来读写需要传递的数据。这个属性的值是一个<code>DataTransfer</code>接口的实例。</p> <p>浏览器原生提供一个<code>DataTransfer()</code>构造函数，用来生成<code>DataTransfer</code>实例对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var dataTrans = new DataTransfer();
</code></pre></div><p><code>DataTransfer()</code>构造函数不接受参数。</p> <p>拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如<code>text/plain</code>、<code>image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p> <p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code>dragenter</code>和<code>dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code>text/uri-list</code>。</p> <p>发生<code>drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</p> <h2 id="_15-datatransfer-的实例属性"><a href="#_15-datatransfer-的实例属性" aria-hidden="true" class="header-anchor">#</a> 15.DataTransfer 的实例属性</h2> <h3 id="_15-1-datatransfer-dropeffect"><a href="#_15-1-datatransfer-dropeffect" aria-hidden="true" class="header-anchor">#</a> 15.1 DataTransfer.dropEffect</h3> <p><code>DataTransfer.dropEffect</code>属性用来设置放下（drop）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p> <blockquote><ul><li>copy：复制被拖拉的节点</li> <li>move：移动被拖拉的节点</li> <li>link：创建指向被拖拉的节点的链接</li> <li>none：无法放下被拖拉的节点</li></ul></blockquote> <p>除了上面这些值，设置其他的值都是无效的。</p> <div class="language- extra-class"><pre class="language-text"><code>target.addEventListener('dragover', function (e) {
  e.preventDefault();
  e.stopPropagation();
  e.dataTransfer.dropEffect = 'copy';
});
</code></pre></div><p>上面代码中，被拖拉元素一旦<code>drop</code>，接受的区域会复制该节点。</p> <p><code>dropEffect</code>属性一般在<code>dragenter</code>和<code>dragover</code>事件的监听函数中设置，对于<code>dragstart</code>、<code>drag</code>、<code>dragleave</code>这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;one&quot; draggable=&quot;true&quot;&gt;可拖动div&lt;/div&gt;
&lt;div&gt; &lt;a href=&quot;&quot;&gt;dadasdasdsadasdasds&lt;/a&gt; &lt;/div&gt;
&lt;script&gt;
    var div = document.getElementById(&quot;one&quot;);
    div.addEventListener('dragover', function (e) {
        console.log(e.dataTransfer.dropEffect)
    }, false);
&lt;/script&gt;
</code></pre></div><h3 id="_15-2-datatransfer-effectallowed"><a href="#_15-2-datatransfer-effectallowed" aria-hidden="true" class="header-anchor">#</a> 15.2 DataTransfer.effectAllowed</h3> <p><code>DataTransfer.effectAllowed</code>属性设置本次拖拉中允许的效果。它可能取下面的值。</p> <blockquote><ul><li>copy：复制被拖拉的节点</li> <li>move：移动被拖拉的节点</li> <li>link：创建指向被拖拉节点的链接</li> <li>copyLink：允许<code>copy</code>或<code>link</code></li> <li>copyMove：允许<code>copy</code>或<code>move</code></li> <li>linkMove：允许<code>link</code>或<code>move</code></li> <li>all：允许所有效果</li> <li>none：无法放下被拖拉的节点</li> <li>uninitialized：默认值，等同于<code>all</code></li></ul></blockquote> <p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p> <p>这个属性与<code>dropEffect</code>属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</p> <p><code>dragstart</code>事件的监听函数，可以用来设置这个属性。其他事件的监听函数里面设置这个属性是无效的。</p> <div class="language- extra-class"><pre class="language-text"><code>source.addEventListener('dragstart', function (e) {
  e.dataTransfer.effectAllowed = 'move';
});

target.addEventListener('dragover', function (e) {
  ev.dataTransfer.dropEffect = 'move';
});
</code></pre></div><p>只要<code>dropEffect</code>属性和<code>effectAllowed</code>属性之中，有一个为<code>none</code>，就无法在目标节点上完成<code>drop</code>操作。</p> <h3 id="_15-3-datatransfer-files"><a href="#_15-3-datatransfer-files" aria-hidden="true" class="header-anchor">#</a> 15.3 DataTransfer.files</h3> <p><code>DataTransfer.files</code>属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</p> <p>下面就是一个接收拖拉文件的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;output&quot; style=&quot;min-height: 200px;border: 1px solid black;&quot;&gt;
    文件拖拉到这里
&lt;/div&gt;
&lt;script&gt;
    var div = document.getElementById('output');
    div.addEventListener(&quot;dragenter&quot;, function( event ) {
        div.textContent = '';
        event.stopPropagation();
        event.preventDefault();
    }, false);
    div.addEventListener(&quot;dragover&quot;, function( event ) {
        event.stopPropagation();
        event.preventDefault();
    }, false);
    div.addEventListener(&quot;drop&quot;, function( event ) {
        event.stopPropagation();
        event.preventDefault();
        var files = event.dataTransfer.files;
        for (var i = 0; i &lt; files.length; i++) {
            div.textContent += files[i].name + ' ' + files[i].size + '字节\n';
        }
    }, false);
&lt;/script&gt;
</code></pre></div><p>上面代码中，通过<code>dataTransfer.files</code>属性读取被拖拉的文件的信息。如果想要读取文件内容，就要使用<code>FileReader</code>对象。</p> <div class="language- extra-class"><pre class="language-text"><code>div.addEventListener('drop', function(e) {
  e.preventDefault();
  e.stopPropagation();
  var fileList = e.dataTransfer.files;
  if (fileList.length &gt; 0) {
    var file = fileList[0];
    var reader = new FileReader();
    reader.onloadend = function(e) {
      if (e.target.readyState === FileReader.DONE) {
        var content = reader.result;
        div.innerHTML = 'File: ' + file.name + '\n\n' + content;
      }
    }
    reader.readAsBinaryString(file);
  }
});
</code></pre></div><h3 id="_15-4-datatransfer-types"><a href="#_15-4-datatransfer-types" aria-hidden="true" class="header-anchor">#</a> 15.4 DataTransfer.types</h3> <p><code>DataTransfer.types</code>属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是<code>text/plain</code>。</p> <p>下面是一个例子，通过检查<code>dataTransfer</code>属性的类型，决定是否允许在当前节点执行<code>drop</code>操作。</p> <div class="language- extra-class"><pre class="language-text"><code>function contains(list, value){
  for (var i = 0; i &lt; list.length; ++i) {
    if(list[i] === value) return true;
  }
  return false;
}

function doDragOver(event) {
  var isLink = contains(event.dataTransfer.types, 'text/uri-list');
  if (isLink) event.preventDefault();
}
</code></pre></div><p>上面代码中，只有当被拖拉的节点是一个链接时，才允许在当前节点放下。</p> <h3 id="_15-5-datatransfer-items"><a href="#_15-5-datatransfer-items" aria-hidden="true" class="header-anchor">#</a> 15.5 DataTransfer.items</h3> <p><code>DataTransfer.items</code>属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</p> <p>DataTransferItemList 实例具有以下的属性和方法。</p> <blockquote><ul><li><code>length</code>：返回成员的数量</li> <li><code>add(data, type)</code>：增加一个指定内容和类型（比如<code>text/html</code>和<code>text/plain</code>）的字符串作为成员</li> <li><code>add(file)</code>：<code>add</code>方法的另一种用法，增加一个文件作为成员</li> <li><code>remove(index)</code>：移除指定位置的成员</li> <li><code>clear()</code>：移除所有的成员</li></ul></blockquote> <p>DataTransferItem 实例具有以下的属性和方法。</p> <blockquote><ul><li><code>kind</code>：返回成员的种类（<code>string</code>还是<code>file</code>）。</li> <li><code>type</code>：返回成员的类型（通常是 MIME 值）。</li> <li><code>getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回<code>null</code>。</li> <li><code>getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li></ul></blockquote> <p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;output&quot; style=&quot;min-height: 200px;border: 1px solid black;&quot;&gt;
    文件拖拉到这里
&lt;/div&gt;
&lt;script&gt;
    var div = document.getElementById('output');
    div.addEventListener(&quot;dragenter&quot;, function( event ) {
        div.textContent = '';
        event.stopPropagation();
        event.preventDefault();
    }, false);
    div.addEventListener(&quot;dragover&quot;, function( event ) {
        event.stopPropagation();
        event.preventDefault();
    }, false);
    div.addEventListener('drop', function (e) {
        e.preventDefault();
        if (e.dataTransfer.items != null) {
            for (var i = 0; i &lt; e.dataTransfer.items.length; i++) {
                console.log(e.dataTransfer.items[i].kind + ': ' + e.dataTransfer.items[i].type);
            }
        }
    });
&lt;/script&gt;
</code></pre></div><p>上面的代码运行后，把文件拖进div中后，会在控制台显示信息。</p> <h2 id="_16-datatransfer-的实例方法"><a href="#_16-datatransfer-的实例方法" aria-hidden="true" class="header-anchor">#</a> 16. DataTransfer 的实例方法</h2> <h3 id="_16-1-datatransfer-setdata"><a href="#_16-1-datatransfer-setdata" aria-hidden="true" class="header-anchor">#</a> 16.1 DataTransfer.setData()</h3> <p><code>DataTransfer.setData()</code>方法用来设置拖拉事件所带有的数据。该方法没有返回值。</p> <div class="language- extra-class"><pre class="language-text"><code>event.dataTransfer.setData('text/plain', 'Text to drag');
</code></pre></div><p>上面代码为当前的拖拉事件加入纯文本数据。</p> <p>该方法接受两个参数，都是字符串。第一个参数表示数据类型（比如<code>text/plain</code>），第二个参数是具体数据。如果指定类型的数据在<code>dataTransfer</code>属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p> <p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到<code>dataTransfer</code>属性，不用手动指定。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div draggable=&quot;true&quot;&gt;
  aaa
&lt;/div&gt;
</code></pre></div><p>上面代码中，拖拉这个<code>&lt;div&gt;</code>元素会自动带上文本数据<code>aaa</code>。</p> <p>使用<code>setData</code>方法，可以替换到原有数据。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div
  draggable=&quot;true&quot;
  ondragstart=&quot;event.dataTransfer.setData('text/plain', 'bbb')&quot;
&gt;
  aaa
&lt;/div&gt;
</code></pre></div><p>上面代码中，拖拉数据实际上是<code>bbb</code>，而不是<code>aaa</code>。</p> <p>下面是添加其他类型的数据。由于<code>text/plain</code>是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>var dt = event.dataTransfer;

// 添加链接
dt.setData('text/uri-list', 'http://www.example.com');
dt.setData('text/plain', 'http://www.example.com');

// 添加 HTML 代码
dt.setData('text/html', 'Hello there, &lt;strong&gt;stranger&lt;/strong&gt;');
dt.setData('text/plain', 'Hello there, &lt;strong&gt;stranger&lt;/strong&gt;');

// 添加图像的 URL
dt.setData('text/uri-list', imageurl);
dt.setData('text/plain', imageurl);
</code></pre></div><p>可以一次提供多种格式的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>var dt = event.dataTransfer;
dt.setData('application/x-bookmark', bookmarkString);
dt.setData('text/uri-list', 'http://www.example.com');
dt.setData('text/plain', 'http://www.example.com');
</code></pre></div><p>上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，<code>drop</code>不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能<code>drop</code>（读取到）这个数据。</p> <h3 id="_16-2-datatransfer-getdata"><a href="#_16-2-datatransfer-getdata" aria-hidden="true" class="header-anchor">#</a> 16.2 DataTransfer.getData()</h3> <p><code>DataTransfer.getData()</code>方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用<code>setData</code>方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有<code>drop</code>事件触发后，才能取出数据。</p> <p>下面是一个<code>drop</code>事件的监听函数，用来取出指定类型的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>function onDrop(event) {
  var data = event.dataTransfer.getData('text/plain');
  event.target.textContent = data;
  event.preventDefault();
}
</code></pre></div><p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p> <p><code>getData</code>方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。</p> <div class="language- extra-class"><pre class="language-text"><code>function doDrop(event) {
  var lines = event.dataTransfer.getData('text/uri-list').split('\n');
  for (let line of lines) {
    let link = document.createElement('a');
    link.href = line;
    link.textContent = line;
    event.target.appendChild(link);
  }
  event.preventDefault();
}
</code></pre></div><p>上面代码中，<code>getData</code>方法返回的是一组链接，就必须自行解析。</p> <p>类型值指定为<code>URL</code>，可以取出第一个有效链接。</p> <div class="language- extra-class"><pre class="language-text"><code>var link = event.dataTransfer.getData('URL');
</code></pre></div><p>下面的例子是从多种类型的数据里面取出数据。</p> <div class="language- extra-class"><pre class="language-text"><code>function doDrop(event) {
  var types = event.dataTransfer.types;
  var supportedTypes = ['text/uri-list', 'text/plain'];
  types = supportedTypes.filter(function (value) { types.includes(value) });
  if (types.length) {
    var data = event.dataTransfer.getData(types[0]);
  }
  event.preventDefault();
}
</code></pre></div><h3 id="_16-3-datatransfer-cleardata"><a href="#_16-3-datatransfer-cleardata" aria-hidden="true" class="header-anchor">#</a> 16.3 DataTransfer.clearData()</h3> <p><code>DataTransfer.clearData()</code>方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</p> <div class="language- extra-class"><pre class="language-text"><code>event.dataTransfer.clearData('text/uri-list');
</code></pre></div><p>上面代码清除事件所带的<code>text/uri-list</code>类型的数据。</p> <p>该方法不会移除拖拉的文件，因此调用该方法后，<code>DataTransfer.types</code>属性可能依然会返回<code>Files</code>类型（前提是存在文件拖拉）。</p> <p>注意，该方法只能在<code>dragstart</code>事件的监听函数之中使用，因为这是拖拉操作的数据唯一可写的时机。</p> <h3 id="_16-4-datatransfer-setdragimage"><a href="#_16-4-datatransfer-setdragimage" aria-hidden="true" class="header-anchor">#</a> 16.4 DataTransfer.setDragImage()</h3> <p>拖动过程中（<code>dragstart</code>事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置。</p> <p><code>DataTransfer.setDragImage()</code>方法可以自定义这张图片。它接受三个参数。第一个是<code>&lt;img&gt;</code>节点或者<code>&lt;canvas&gt;</code>节点，如果省略或为<code>null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。</p> <p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;drag-with-image&quot; class=&quot;dragdemo&quot; draggable=&quot;true&quot;&gt;
    drag me
&lt;/div&gt;
&lt;script&gt;
    var div = document.getElementById('drag-with-image');
    div.addEventListener('dragstart', function (e) {
        var img = document.createElement('img');
        img.src = 'http://path/to/img';
        e.dataTransfer.setDragImage(img, 0, 0);
    }, false);
&lt;/script&gt;
</code></pre></div><h2 id="_17-触摸操作概述"><a href="#_17-触摸操作概述" aria-hidden="true" class="header-anchor">#</a> 17. 触摸操作概述</h2> <p>浏览器的触摸 API 由三个部分组成。</p> <blockquote><ul><li>Touch：一个触摸点</li> <li>TouchList：多个触摸点的集合</li> <li>TouchEvent：触摸引发的事件实例</li></ul></blockquote> <p><code>Touch</code>接口的实例对象用来触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p> <p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用<code>event.preventDefault</code>方法阻止发出鼠标事件。</p> <h2 id="_18-touch接口"><a href="#_18-touch接口" aria-hidden="true" class="header-anchor">#</a> 18. Touch接口</h2> <h3 id="_18-1-touch接口概述"><a href="#_18-1-touch接口概述" aria-hidden="true" class="header-anchor">#</a> 18.1 Touch接口概述</h3> <p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。</p> <p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p> <div class="language- extra-class"><pre class="language-text"><code>var touch = new Touch(touchOptions);
</code></pre></div><p><code>Touch</code>构造函数接受一个配置对象作为参数，它有以下属性。</p> <blockquote><ul><li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li> <li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li> <li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li> <li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li> <li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li> <li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li> <li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li> <li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li> <li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li> <li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li> <li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li> <li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li></ul></blockquote> <h3 id="_18-2-touch-接口的实例属性"><a href="#_18-2-touch-接口的实例属性" aria-hidden="true" class="header-anchor">#</a> 18.2 Touch 接口的实例属性</h3> <p><strong>（1）Touch.identifier</strong></p> <p><code>Touch.identifier</code>属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p> <div class="language- extra-class"><pre class="language-text"><code>someElement.addEventListener('touchmove', function (e) {
  for (var i = 0; i &lt; e.changedTouches.length; i++) {
    console.log(e.changedTouches[i].identifier);
  }
}, false);
</code></pre></div><p><strong>（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY</strong></p> <p><code>Touch.screenX</code>属性和<code>Touch.screenY</code>属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</p> <p><code>Touch.clientX</code>属性和<code>Touch.clientY</code>属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</p> <p><code>Touch.pageX</code>属性和<code>Touch.pageY</code>属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</p> <p><strong>（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle</strong></p> <p><code>Touch.radiusX</code>属性和<code>Touch.radiusY</code>属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。</p> <p><code>Touch.rotationAngle</code>属性表示触摸区域的椭圆的旋转角度，单位为度数，在<code>0</code>到<code>90</code>度之间。</p> <p>上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p> <p>下面是一个示例。</p> <div class="language- extra-class"><pre class="language-text"><code>div.addEventListener('touchstart', rotate);
div.addEventListener('touchmove', rotate);
div.addEventListener('touchend', rotate);

function rotate(e) {
  var touch = e.changedTouches.item(0);
  e.preventDefault();

  src.style.width = touch.radiusX * 2 + 'px';
  src.style.height = touch.radiusY * 2 + 'px';
  src.style.transform = 'rotate(' + touch.rotationAngle + 'deg)';
};
</code></pre></div><p><strong>（4）Touch.force</strong></p> <p><code>Touch.force</code>属性返回一个<code>0</code>到<code>1</code>之间的数值，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力。</p> <p><strong>（5）Touch.target</strong></p> <p><code>Touch.target</code>属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
    html,body {height: 100%}
&lt;/style&gt;
&lt;script&gt;
    document.body.addEventListener('touchstart', function (e) {
        console.log(&quot;identifier: &quot;, e.touches[0].identifier)
        console.log(&quot;screenX: &quot;, e.touches[0].screenX)
        console.log(&quot;screenY: &quot;, e.touches[0].screenY)
        console.log(&quot;clientX: &quot;, e.touches[0].clientX)
        console.log(&quot;clientY: &quot;, e.touches[0].clientY)
        console.log(&quot;pageX: &quot;, e.touches[0].pageX)
        console.log(&quot;pageY: &quot;, e.touches[0].pageY)
        console.log(&quot;radiusX: &quot;, e.touches[0].radiusX)
        console.log(&quot;radiusY: &quot;, e.touches[0].radiusY)
        console.log(&quot;rotationAngle: &quot;, e.touches[0].rotationAngle)
        console.log(&quot;force : &quot;, e.touches[0].force )
        console.log(&quot;target  : &quot;, e.touches[0].target)
    }, false);
&lt;/script&gt;
</code></pre></div><p>上面的代码在Google的chrome浏览器中，打开开发者模式，设置为手机模式，点击一下屏幕就能看见输出。</p> <h2 id="_19-touchlist-接口"><a href="#_19-touchlist-接口" aria-hidden="true" class="header-anchor">#</a> 19. TouchList 接口</h2> <p><code>TouchList</code>接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是<code>Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code>TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code>Touch</code>实例对象。</p> <p>它的实例主要通过触摸事件的<code>TouchEvent.touches</code>、<code>TouchEvent.changedTouches</code>、<code>TouchEvent.targetTouches</code>这几个属性获取。</p> <p>它的实例属性和实例方法只有两个。</p> <ul><li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li> <li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
    html,body {height: 100%}
&lt;/style&gt;
&lt;script&gt;
    document.body.addEventListener('touchstart', function (e) {
        console.log(&quot;类型: &quot;,  e.touches instanceof TouchList )	// true
        console.log(&quot;length: &quot;, e.touches.length)	// 1
        console.log(&quot;item(): &quot;, e.touches.item(0))	// Touch {identifier: 0, target
    }, false);
    // Chrome 版本 66.0.3359.181（正式版本） （64 位）
&lt;/script&gt;
</code></pre></div><p>上面的代码在chrome中开发者模式，手机模式，点击一下查看效果</p> <h2 id="_20-touchevent-接口"><a href="#_20-touchevent-接口" aria-hidden="true" class="header-anchor">#</a> 20. TouchEvent 接口</h2> <h3 id="_20-1-概述"><a href="#_20-1-概述" aria-hidden="true" class="header-anchor">#</a> 20.1 概述</h3> <p>TouchEvent 接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p> <p>浏览器原生提供<code>TouchEvent()</code>构造函数，用来生成触摸事件的实例。</p> <div class="language- extra-class"><pre class="language-text"><code>new TouchEvent(type, options)
</code></pre></div><p><code>TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了<code>Event</code>接口的配置属性，该接口还有一些自己的配置属性。</p> <ul><li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li> <li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li> <li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li> <li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li> <li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li> <li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li> <li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code>。</li></ul> <h3 id="_20-2-实例属性"><a href="#_20-2-实例属性" aria-hidden="true" class="header-anchor">#</a> 20.2 实例属性</h3> <p>TouchEvent 接口的实例具有<code>Event</code>实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p> <p><strong>（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey</strong></p> <ul><li><code>TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li> <li><code>TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li> <li><code>TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li> <li><code>TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li></ul> <p>下面是一个示例</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
    html,body {height: 100%}
&lt;/style&gt;
&lt;script&gt;
    document.body.addEventListener('touchstart', function (e) {
        console.log('altKey = ' + e.altKey);
        console.log('ctrlKey = ' + e.ctrlKey);
        console.log('metaKey = ' + e.metaKey);
        console.log('shiftKey = ' + e.shiftKey);
    }, false);
&lt;/script&gt;
</code></pre></div><p>chrome开发者打开手机模式，点击一下即可查看效果。</p> <p><strong>（2）TouchEvent.changedTouches</strong></p> <p><code>TouchEvent.changedTouches</code>属性返回一个<code>TouchList</code>实例，成员是一组<code>Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p> <p>对于不同的时间，该属性的含义有所不同。</p> <ul><li><code>touchstart</code>事件：被激活的触摸点</li> <li><code>touchmove</code>事件：发生变化的触摸点</li> <li><code>touchend</code>事件：消失的触摸点（即不再被触碰的点）</li></ul> <p>下面是一个示例。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
    html,body {height: 100%}
&lt;/style&gt;
&lt;script&gt;
    document.body.addEventListener('touchmove', function (e) {
        for (var i = 0; i &lt; e.changedTouches.length; i++) {
            console.log(e.changedTouches[i].identifier);
        }
    }, false);
&lt;/script&gt;
</code></pre></div><p><strong>（3）TouchEvent.touches</strong></p> <p><code>TouchEvent.touches</code>属性返回一个<code>TouchList</code>实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。</p> <p>下面是一个示例。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
    html,body {height: 100%}
&lt;/style&gt;
&lt;script&gt;
    document.body.addEventListener('touchstart', function (e) {
        console.log(e.touches.length)
        //       switch (e.touches.length) {
        //           // 一根手指触摸
        //         case 1: handle_one_touches(e); break;
        //           // 两根手指触摸
        //         case 2: handle_two_touches(e); break;
        //           // 三根手指触摸
        //         case 3: handle_three_touches(e); break;
        //           // 其他情况
        //         default: console.log('Not supported'); break;
        //       }
    }, false);
&lt;/script&gt;
</code></pre></div><p><strong>（4）TouchEvent.targetTouches</strong></p> <p><code>TouchEvent.targetTouches</code>属性返回一个<code>TouchList</code>实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。</p> <div class="language- extra-class"><pre class="language-text"><code>function touches_in_target(ev) {
  return (ev.touches.length === ev.targetTouches.length ? true : false);
}
</code></pre></div><p>上面代码用来判断，是否所有触摸点都在目标元素内。</p> <h2 id="_21-触摸事件的种类"><a href="#_21-触摸事件的种类" aria-hidden="true" class="header-anchor">#</a> 21. 触摸事件的种类</h2> <p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p> <ul><li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li> <li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li> <li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li> <li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个情态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li></ul> <p>下面是一个例子</p> <div class="language- extra-class"><pre class="language-text"><code>var el = document.getElementsByTagName('canvas')[0];
el.addEventListener('touchstart', handleStart, false);
el.addEventListener('touchmove', handleMove, false);

function handleStart(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  for (var i = 0; i &lt; touches.length; i++) {
    console.log(touches[i].pageX, touches[i].pageY);
  }
}

function handleMove(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  for (var i = 0; i &lt; touches.length; i++) {
    var touch = touches[i];
    console.log(touch.pageX, touch.pageY);
  }
}
</code></pre></div><h2 id="_22-表单事件的种类"><a href="#_22-表单事件的种类" aria-hidden="true" class="header-anchor">#</a> 22. 表单事件的种类</h2> <h3 id="_22-1-input-事件"><a href="#_22-1-input-事件" aria-hidden="true" class="header-anchor">#</a> 22.1 input 事件</h3> <p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。对于复选框（<code>&lt;input type=checkbox&gt;</code>）或单选框（<code>&lt;input type=radio&gt;</code>），用户改变选项时，也会触发这个事件。另外，对于打开<code>contenteditable</code>属性的元素，只要值发生变化，也会触发<code>input</code>事件。</p> <p><code>input</code>事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次<code>input</code>事件。</p> <p><code>input</code>事件对象继承了<code>InputEvent</code>接口。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;
&lt;script&gt;
    var elem = document.getElementById('test');
    elem.addEventListener('input', function (e) {
        console.log(e.type); // &quot;input&quot;
    }, false);
&lt;/script&gt;
</code></pre></div><p>上面的代码执行后，输入框中每次值的变化都会触发input事件。</p> <h3 id="_22-2-select-事件"><a href="#_22-2-select-事件" aria-hidden="true" class="header-anchor">#</a> 22.2 select 事件</h3> <p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面选中文本时触发。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;
  &lt;script&gt;
    var elem = document.getElementById('test');
    elem.addEventListener('select', function (e) {
      console.log(e.type); // &quot;select&quot;
    }, false);
  &lt;/script&gt;
</code></pre></div><p>选中的文本可以通过<code>event.target</code>元素的<code>selectionDirection</code>、<code>selectionEnd</code>、<code>selectionStart</code>和<code>value</code>属性拿到。</p> <h3 id="_22-3-change-事件"><a href="#_22-3-change-事件" aria-hidden="true" class="header-anchor">#</a> 22.3 Change 事件</h3> <p><code>Change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。它与<code>input</code>事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p> <ul><li>激活单选框（radio）或复选框（checkbox）时触发。</li> <li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li> <li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li></ul> <p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function changeEventHandler(event) {
        console.log(event.target.value);
    }
&lt;/script&gt;

&lt;select size=&quot;1&quot; onchange=&quot;changeEventHandler(event);&quot;&gt;
    &lt;option&gt;chocolate&lt;/option&gt;
    &lt;option&gt;strawberry&lt;/option&gt;
    &lt;option&gt;vanilla&lt;/option&gt;
&lt;/select&gt;
</code></pre></div><h3 id="_22-4-invalid-事件"><a href="#_22-4-invalid-事件" aria-hidden="true" class="header-anchor">#</a> 22.4 invalid 事件</h3> <p>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code>invalid</code>事件。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form&gt;
  &lt;input type=&quot;text&quot; required oninvalid=&quot;console.log('invalid input')&quot; /&gt;
  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;
</code></pre></div><p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code>invalid</code>事件，导致提交被取消。</p> <h3 id="_22-5-reset-事件，submit-事件"><a href="#_22-5-reset-事件，submit-事件" aria-hidden="true" class="header-anchor">#</a> 22.5 reset 事件，submit 事件</h3> <p>这两个事件发生在表单对象<code>&lt;form&gt;</code>上，而不是发生在表单的成员上。</p> <p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发。</p> <p><code>submit</code>事件当表单数据向服务器提交时触发。注意，<code>submit</code>事件的发生对象是<code>&lt;form&gt;</code>元素，而不是<code>&lt;button&gt;</code>元素，因为提交的是表单，而不是按钮。</p> <h2 id="_23-资源事件"><a href="#_23-资源事件" aria-hidden="true" class="header-anchor">#</a> 23. 资源事件</h2> <h3 id="_23-1-beforeunload-事件"><a href="#_23-1-beforeunload-事件" aria-hidden="true" class="header-anchor">#</a> 23.1 beforeunload 事件</h3> <p><code>beforeunload</code>事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。</p> <p>如果该事件对象的<code>returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('beforeunload', function(event) {
  event.returnValue = '你确定离开吗？';
});
</code></pre></div><p>上面代码中，用户如果关闭窗口，浏览器会弹出一个窗口，要求用户确认。</p> <p>浏览器对这个事件的行为很不一致，有的浏览器调用<code>event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。因此，可以采用下面的写法，取得最大的兼容性。</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('beforeunload', function(e) {
  var confirmationMessage = '确认关闭窗口？';
  e.returnValue = confirmationMessage;
  return confirmationMessage;
});
</code></pre></div><p>注意，许多手机浏览器默认忽略这个事件，桌面浏览器也有方法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭窗口。</p> <h3 id="_23-2-unload-事件"><a href="#_23-2-unload-事件" aria-hidden="true" class="header-anchor">#</a> 23.2 unload 事件</h3> <p><code>unload</code>事件在窗口关闭或者<code>document</code>对象将要卸载时触发。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。<code>unload</code>事件只在页面没有被浏览器缓存时才会触发，换言之，如果通过按下“前进/后退”导致页面卸载，并不会触发<code>unload</code>事件。</p> <p><code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('unload', function(event) {
  console.log('文档将要卸载');
});
</code></pre></div><h3 id="_23-3-load-事件"><a href="#_23-3-load-事件" aria-hidden="true" class="header-anchor">#</a> 23.3 load 事件</h3> <p><code>load</code>事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('load', function(event) {
  console.log('所有资源都加载完成');
});
</code></pre></div><p><code>error</code>事件是在页面或资源加载失败时触发。<code>abort</code>事件在用户取消加载时触发。</p> <p>这三个事件实际上属于进度事件，不仅发生在<code>document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和<code>document</code>对象、<code>window</code>对象、XMLHttpRequestUpload 对象，都会触发<code>load</code>事件和<code>error</code>事件。</p> <h2 id="_24-session-历史事件"><a href="#_24-session-历史事件" aria-hidden="true" class="header-anchor">#</a> 24. session 历史事件</h2> <h3 id="_24-1-pageshow-事件，pagehide-事件"><a href="#_24-1-pageshow-事件，pagehide-事件" aria-hidden="true" class="header-anchor">#</a> 24.1 pageshow 事件，pagehide 事件</h3> <p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</p> <p>pageshow 事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p> <p>第一次加载时，它的触发顺序排在<code>load</code>事件后面。从缓存加载时，<code>load</code>事件不会触发，因为网页在缓存中的样子通常是<code>load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('pageshow', function(event) {
  console.log('pageshow: ', event);
});
</code></pre></div><p>pageshow 事件有一个<code>persisted</code>属性，返回一个布尔值。页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('pageshow', function(event){
  if (event.persisted) {
    // ...
  }
});
</code></pre></div><p><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</p> <p><code>pagehide</code>事件实例也有一个<code>persisted</code>属性，将这个属性设为<code>true</code>，就表示页面要保存在缓存中；设为<code>false</code>，表示网页不保存在缓存中，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p> <p>如果页面包含<code>&lt;frame&gt;</code>或<code>&lt;iframe&gt;</code>元素，则<code>&lt;frame&gt;</code>页面的<code>pageshow</code>事件和<code>pagehide</code>事件，都会在主页面之前触发。</p> <h3 id="_24-2-popstate-事件"><a href="#_24-2-popstate-事件" aria-hidden="true" class="header-anchor">#</a> 24.2 popstate 事件</h3> <p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发。</p> <p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p> <div class="language- extra-class"><pre class="language-text"><code>window.onpopstate = function (event) {
  console.log('state: ' + event.state);
};
history.pushState({page: 1}, 'title 1', '?page=1');
history.pushState({page: 2}, 'title 2', '?page=2');
history.replaceState({page: 3}, 'title 3', '?page=3');
history.back(); // state: {&quot;page&quot;:1}
history.back(); // state: null
history.go(2);  // state: {&quot;page&quot;:3}
</code></pre></div><p>上面代码中，<code>pushState</code>方法向<code>history</code>添加了两条记录，然后<code>replaceState</code>方法替换掉当前记录。因此，连续两次<code>back</code>方法，会让当前条目退回到原始网址，它没有附带<code>state</code>对象，所以事件的<code>state</code>属性为<code>null</code>，然后前进两条记录，又回到<code>replaceState</code>方法添加的记录。</p> <p>浏览器对于页面首次加载，是否触发<code>popstate</code>事件，处理不一样，Firefox 不触发该事件。</p> <h3 id="_24-3-hashchange-事件"><a href="#_24-3-hashchange-事件" aria-hidden="true" class="header-anchor">#</a> 24.3 hashchange 事件</h3> <p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听。</p> <p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p> <div class="language- extra-class"><pre class="language-text"><code>// URL 是 http://www.example.com/
window.addEventListener('hashchange', myFunction);
function myFunction(e) {
  console.log(e.oldURL);
  console.log(e.newURL);
}
location.hash = 'part2';
// http://www.example.com/
// http://www.example.com/#part2
</code></pre></div><h2 id="_25-网页状态事件"><a href="#_25-网页状态事件" aria-hidden="true" class="header-anchor">#</a> 25. 网页状态事件</h2> <h3 id="_25-1-domcontentloaded-事件"><a href="#_25-1-domcontentloaded-事件" aria-hidden="true" class="header-anchor">#</a> 25.1 DOMContentLoaded 事件</h3> <p>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比<code>load</code>事件，发生时间早得多。</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('DOMContentLoaded', function (event) {
  console.log('DOM生成');
});
</code></pre></div><p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('DOMContentLoaded', function (event) {
  console.log('DOM 生成');
});

// 这段代码会推迟触发 DOMContentLoaded 事件
for(var i = 0; i &lt; 1000000000; i++) {
  // ...
}
</code></pre></div><h3 id="_25-2-readystatechange-事件"><a href="#_25-2-readystatechange-事件" aria-hidden="true" class="header-anchor">#</a> 25.2 readystatechange 事件</h3> <p><code>readystatechange</code>事件当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发。<code>document.readyState</code>有三个可能的值：</p> <ul><li><code>loading</code>（网页正在加载）</li> <li><code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）</li> <li><code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>document.onreadystatechange = function () {
  if (document.readyState === 'interactive') {
    // ...
  }
}
</code></pre></div><p>这个事件可以看作<code>DOMContentLoaded</code>事件的另一种实现方法。</p> <h2 id="_26-窗口事件"><a href="#_26-窗口事件" aria-hidden="true" class="header-anchor">#</a> 26. 窗口事件</h2> <h3 id="_26-1-scroll-事件"><a href="#_26-1-scroll-事件" aria-hidden="true" class="header-anchor">#</a> 26.1 scroll 事件</h3> <p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;one&quot; style=&quot;height: 100px; overflow: scroll;&quot;&gt;
    &lt;p&gt;1&lt;/p&gt;&lt;p&gt;1&lt;/p&gt;&lt;p&gt;2&lt;/p&gt;&lt;p&gt;3&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    document.getElementById(&quot;one&quot;).addEventListener('scroll', function(e) {
        console.log(e);
    });
&lt;/script&gt;
</code></pre></div><p>该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p> <div class="language- extra-class"><pre class="language-text"><code>(function () {
  var throttle = function (type, name, obj) {
    var obj = obj || window;
    var running = false;
    var func = function () {
      if (running) { return; }
      running = true;
      requestAnimationFrame(function() {
        obj.dispatchEvent(new CustomEvent(name));
        running = false;
      });
    };
    obj.addEventListener(type, func);
  };

  // 将 scroll 事件重定义为 optimizedScroll 事件
  throttle('scroll', 'optimizedScroll');
})();
window.addEventListener('optimizedScroll', function() {
  console.log('Resource conscious scroll callback!');
});
</code></pre></div><p>上面代码中，<code>throttle</code>函数用于控制事件触发频率，<code>requestAnimationFrame</code>方法保证每次页面重绘（每秒60次），只会触发一次<code>scroll</code>事件的监听函数。也就是说，上面方法将<code>scroll</code>事件的触发频率，限制在每秒60次。具体来说，就是<code>scroll</code>事件只要频率低于每秒60次，就会触发<code>optimizedScroll</code>事件，从而执行<code>optimizedScroll</code>事件的监听函数。</p> <p>改用<code>setTimeout</code>方法，可以放置更大的时间间隔。</p> <div class="language- extra-class"><pre class="language-text"><code>(function() {
  window.addEventListener('scroll', scrollThrottler, false);

  var scrollTimeout;
  function scrollThrottler() {
    if (!scrollTimeout) {
      scrollTimeout = setTimeout(function () {
        scrollTimeout = null;
        actualScrollHandler();
      }, 66);
    }
  }

  function actualScrollHandler() {
    // ...
  }
}());
</code></pre></div><p>上面代码中，每次<code>scroll</code>事件都会执行<code>scrollThrottler</code>函数。该函数里面有一个定时器<code>setTimeout</code>，每66毫秒触发一次（每秒15次）真正执行的任务<code>actualScrollHandler</code>。</p> <p>下面是一个更一般的<code>throttle</code>函数的写法。</p> <div class="language- extra-class"><pre class="language-text"><code>function throttle(fn, wait) {
  var time = Date.now();
  return function() {
    if ((time + wait - Date.now()) &lt; 0) {
      fn();
      time = Date.now();
    }
  }
}
window.addEventListener('scroll', throttle(callback, 1000));
</code></pre></div><p>上面的代码将<code>scroll</code>事件的触发频率，限制在一秒一次。</p> <p><code>lodash</code>函数库提供了现成的<code>throttle</code>函数，可以直接使用。</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('scroll', _.throttle(callback, 1000));
</code></pre></div><h3 id="_26-2-resize-事件"><a href="#_26-2-resize-事件" aria-hidden="true" class="header-anchor">#</a> 26.2 resize 事件</h3> <p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p> <div class="language- extra-class"><pre class="language-text"><code>var resizeMethod = function () {
  if (document.body.clientWidth &lt; 768) {
    console.log('移动设备的视口');
  }
};
window.addEventListener('resize', resizeMethod, true);
</code></pre></div><p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p> <h3 id="_26-3-fullscreenchange-事件，fullscreenerror-事件"><a href="#_26-3-fullscreenchange-事件，fullscreenerror-事件" aria-hidden="true" class="header-anchor">#</a> 26.3 fullscreenchange 事件，fullscreenerror 事件</h3> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('fullscreenchange', function (event) {
  console.log(document.fullscreenElement);
});
</code></pre></div><p><code>fullscreenerror</code>事件在浏览器无法切换到全屏状态时触发。</p> <h2 id="_27-剪贴板事件"><a href="#_27-剪贴板事件" aria-hidden="true" class="header-anchor">#</a> 27. 剪贴板事件</h2> <p>以下三个事件属于剪贴板操作的相关事件。</p> <ul><li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li> <li><code>copy</code>：进行复制动作时触发。</li> <li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li></ul> <p>这三个事件都是<code>ClipboardEvent</code>接口的实例。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《触摸事件》的 DataTransfer 对象部分。</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('copy', function (e) {
  e.clipboardData.setData('text/plain', 'Hello, world!');
  e.clipboardData.setData('text/html', '&lt;b&gt;Hello, world!&lt;/b&gt;');
  e.preventDefault();
});
</code></pre></div><p>上面代码执行后，在页面复制(cmd + c), 然后在别的地方粘贴的内容会是<code>Hello, world!</code>.</p> <p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p> <h2 id="_28-焦点事件"><a href="#_28-焦点事件" aria-hidden="true" class="header-anchor">#</a> 28. 焦点事件</h2> <p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p> <ul><li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li> <li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li> <li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li> <li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li></ul> <p>这四个事件都继承了<code>FocusEvent</code>接口。<code>FocusEvent</code>实例具有以下属性。</p> <ul><li><code>FocusEvent.target</code>：事件的目标节点。</li> <li><code>FocusEvent.relatedTarget</code>：对于<code>focusin</code>事件，返回失去焦点的节点；对于<code>focusout</code>事件，返回将要接受焦点的节点；对于<code>focus</code>和<code>blur</code>事件，返回<code>null</code>。</li></ul> <p>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>form.addEventListener('focus', function (event) {
  event.target.style.background = 'pink';
}, true);

form.addEventListener('blur', function (event) {
  event.target.style.background = '';
}, true);
</code></pre></div><p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p> <h2 id="_29-参考资料"><a href="#_29-参考资料" aria-hidden="true" class="header-anchor">#</a> 29. 参考资料</h2> <p><a href="https://wangdoc.com/javascript/events/index.html" target="_blank" rel="noopener noreferrer">事件 阮一峰 网道<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://javascript.ruanyifeng.com/dom/event-type.html" target="_blank" rel="noopener noreferrer">事件种类  阮一峰<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://js.jirengu.com/" target="_blank" rel="noopener noreferrer">在线代码测试 JSbin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/yulilong/front-end-doc/edit/master/doc/dom/010-事件种类.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">4/18/2020, 4:44:55 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/81.3891d4d6.js" defer></script><script src="/assets/js/app.775950a1.js" defer></script>
  </body>
</html>
